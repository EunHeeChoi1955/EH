var store = [{
        "title": "[기술 면접 기초 질문] Next Step 기술 면접 예상 질문",
        "excerpt":"넥스트 스텝 이력서 / 면접 멘토링   기술 면접 예상 질문 / 답변     자문자답입니다.   질문의 순서는 무의미합니다.   간결한 답변을 위해 생략된 부분이 있습니다.   운영체제   멀티 프로세스 방식과 멀티 스레드 방식의 차이는?  먼저 프로세스와 스레드의 정의를 짚고 가겠습니다.     프로세스는 운영체제 내에서 하나의 프로그램이 실행되어 메모리에 적재된 상태, 작업 단위입니다.   스레드는 프로세스 내에서 작업을 실행하는 작업 흐름의 단위입니다.   하나의 프로세스는 하나 이상의 스레드를 가지고 있습니다. 따라서 프로세스가 동작하면 적어도 1개 이상의 스레드가 이를 처리하게 됩니다. 두 방식의 차이점으로 먼저 프로세스는 서로 다른 프로세스 간의 메모리를 공유하지 않습니다. 물론 메모리를 공유하는 방법이 아예 없는 것은 아니나 번거롭고 성능 저하 등의 문제가 있습니다. 그래서 멀티 프로세스 간의 실행은 문맥 교환(Context Switching)에 들어가는 리소스가 많은 편입니다. 반면에 스레드는 하나의 프로세스 안에서 적정 범위의 메모리를 공유하게 됩니다. 이로 인해 스레드 간의 문맥 교환에 들어가는 리소스는 멀티 프로세스 환경 대비 적은 편입니다.   하지만 멀티 스레드 환경의 문제점은 하나의 스레드에서 발생한 문제가 공유 메모리와 다른 스레드에게 영향을 끼칠 수 있다는 점입니다. 예를 들어 자바는 이 멀티스레드 기능을 지원합니다. JVM 메모리 영역의 구조는 Heap Area, Stack Area, Method Area, PC Registers, Native Method Stacks으로 구성되어 있습니다. 여기서 Stack, PC register, Native Method 영역은 스레드 독립적이나 Heap, Method 영역은 스레드가 공유하는 영역입니다. 자바 프로그래밍에서 멀티 스레드 환경으로 개발을 진행하다 보면 공유되는 Heap 영역에 데이터로 인해서 메서드의 멱등성이 깨지게 됩니다. 이로 인해 데이터가 달라지는데 이를 추적, 디버깅하는 방법이 다소 까다롭습니다. 해결 방법으로는 synchronized 키워드를 통해 동기화를 제어하는 방법이 있습니다. 그래서 크롬 브라우저에서의 탭 기능은 멀티 스레드가 아닌 멀티 프로세스 환경으로 구현되어 있기도 합니다.     Java   자바의 클래스 로딩 절차는?  JVM에서 클래스 로딩 수행 절차는 크게 로딩(Loading), 링킹(Linking), 초기화(Initialization)로 나눠집니다. 로딩은 바이트 코드(클래스 파일)를 읽어 메서드 영역에 저장하는 기능이며, 링킹은 이를 검증, 실제 레퍼런스와 연결합니다. 이후 스태틱 클래스, 스태틱 변수 값 등을 초기화합니다.   클래스 로더     런타임에 로딩 작업을 수행하는 모듈입니다.   일반적으로 Bootstrap, Platform(Extension), System(Application)가 있습니다.   User-Defined은 사용자 정의 클래스 로더입니다(최하위 위치).   클래스 로더 속성     Hierarchical(계층적)            클래스 로더는 상속 관계로 구성되어 있습니다.       Bootstrap(최상위) - Platform - System - User-Defined           Delegate(위임)            로딩 요청을 최상위 로더에게 위임한 후 하위 로더로 내려오며 로딩이 수행됩니다.           Visibility(가시성)            하위 클래스 로더는 상위 클래스 로더의 내용을 볼 수 있으나 반대로는 불가능합니다.           Uniqueness(유일성)            상위 클래스 로더에서 클래스 로딩한 클래스를 하위 클래스 로더에서 다시 로딩하지 않게 합니다.           링킹의 절차     Verification(검증)            JVM에서 사용할 수 있는 유효한 바이너리 코드인지 검증합니다.           Preparation(준비)            Type이 필요로 하는 메모리를 할당합니다.           Resolution(링크 변경)            심볼릭 레퍼런스를 실제 레퍼런스로 변경합니다.       클래스 로더의 순서대로 실행 됩니다.           초기화     스태틱 블럭 실행, 스태틱 변수의 값과 스태틱 클래스의 초기화 등을 진행합니다.   이러한 클래스 로딩 메커니즘이 활용된 실제 사례로는 spring-boot-devtools의 Automatic Restart 기능이 있습니다. 스프링 부트에서 제공하는 Devtools는 개발 시간 단축에 도움을 주는 도구입니다. 이를 사용하면 클래스 패스의 파일이 변경되는 경우 자동으로 재시작합니다. 스프링 부트는 기본적으로 Base Class Loader와 Restart Class Loader로 구성되어 있습니다. Base Class Loader는 기본적으로 바뀌지 않는 기본 클래스 로더입니다. Restart Class Loader는 Application에서 사용하는 일반적인 클래스 로더입니다. 이 경우 Restart Class Loader만 지우고 다시 생성하여 더 빠르게 프로젝트를 로딩시킬 수 있습니다. Base Class Loader는 영향을 받지 않기 때문에 스프링 부트 프로젝트를 직접 종료 후 재시작하는 것보다 빠릅니다.   스프링 부트 프레임워크는 상당히 무겁기 때문에 변경되지 않는 클래스들을 그대로 둔채 변경되는 클래스만 재로딩하는 것은 효율적이라고 생각합니다. DevTools는 자주 재시작을 해야 하는 개발 환경에서 개발 시간을 많이 줄여 개발 생산성 향상에 도움이 됩니다. 몰라도 되는 부분이지만 이러한 부분까지 고려하여 편의성을 제공하고 있다는 것에 대해 한 번 더 생각해보면 좋겠습니다.     자바의 애너테이션이란 무엇인가?  자바의 에너테이션은 메타데이터를 가리키는 일종의 주석입니다. @interface 형태로 애너테이션을 선언할 수 있고 설정에 따라 클래스, 메서드, 인스턴스 변수 등에 태깅할 수 있습니다. 애너테이션의 종류로는 표준 에너테이션, 메타 에너테이션, 마커 애네터이션 등이 있습니다. 애너테이션 선언 시 @Retention, @Target, @Repeatable 등 메타 애너테이션을 이용해 속성을 설정할 수 있습니다. 태그와 같이 말 그대로 특정 데이터임을 암시하거나 특정 작업을 처리하게끔 사용할 수 있습니다.   대표적인 활용 예시는 @Deprecated, @FunctionalInterface 등과 같은 표준 애너테이션이 있습니다. @Deprecated 애너테이션은 더는 사용되지 않음을 의미하며 사용시 주의를 의미하고 있습니다. @FunctionalInterface 애너테이션은 함수형 인터페이스를 가리키며 추상 메서드가 2개 이상일시 컴파일 에러를 야기합니다.   개인적으로는 테스트 용도의 StopWatch 기능을 스프링 부트의 AOP(애너테이션)를 활용해 구현한 적이 있습니다. 특정 메서드에 해당 애너테이션을 태깅하여 메서드 처리 시간을 측정하는 기능이었습니다. 예를 들면 아래와 같은 방식으로 애너테이션과 해당 애너테이션을 처리하는 Aspect 클래스를 작성하였습니다.  @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface StopWatch { }  @Aspect @Component public class LoggingAspect {      @Around(\"@annotation(StopWatch)\")     public Object stopWatch(ProceedingJoinPoint joinPoint) throws Throwable {         StopWatch stopWatch = new StopWatch();          String className = joinPoint.getSignature().getName();          try {             stopWatch.start();             Object proceed = joinPoint.proceed();             stopWatch.stop();             LOGGER.info(\"elapsed time :: {}\", stopWatch.getTotalTimeMillis());                          return prceed;         }          return null;     } }  여기서 @Aspect는 해당 객체가 흩어진 관심사를 모아둔 모듈(횡단으로 실행할 로직)임을 의미하며 @Around는 대상 객체를 설정합니다. joinPoint.proceed(); 를 전후로 스탑워치 시작과 종료 기능을 호출하여 시간을 측정 후 출력시키는 방식으로 구현하였습니다.   애너테이션을 사용하면 간편하게 구현할 수 있고, 구현 코드가 짧아진다는 장점이 있습니다. 하지만 당연히 단점도 있습니다. 첫 번째로 애너테이션 사용은 리플렉션 처리로 인해 파일 로딩에 성능 부분에 오버해드가 존재합니다. 두 번째로 XML 파일 사용은 리컴파일이 필요 없는데 반해 애너테이션 사용은 리컴파일이 필요하다는 단점이 있습니다. 그리고 프로젝트 전반에 대한 설정 등은 애너테이션으로 설정할 수 없습니다. 이 경우 XML 파일을 사용해야 합니다.   따라서 개발 환경에 의존하여 자주 변경될 가능성이 있는 정보는 XML, 앱 내에 런타임에 결정되는 정보는 애너테이션을 사용하는 등 이러한 장단점을 잘 이용한다면 개발 생산성을 높여줄 것입니다.     데이터베이스   DB 인덱스란?  데이터베이스에서 테이블의 데이터 핸들링 시 작업 속도를 향상하게 시켜주는 자료구조, 기능입니다. 인덱스는 하나 이상의 컬럼(열)을 사용하여 생성 가능하며, 레코드의 빠른 조회 등을 위한 기반을 제공합니다. 일반적으로 인덱스는 데이터 조회처리에서 성능 향상을 목적으로 하며 삽입, 수정, 삭제 등의 쿼리는 성능이 저하됩니다. 하지만 수정, 삭제 시 조회 부분이 인덱스를 사용한다면 데이터를 찾는 것 자체는 빠를 것입니다. 다시 말해 인덱스는 조회 성능을 위해 메모리 영역에 목차를 생성하는 것이라 볼 수 있습니다. 인덱스를 선정할 때는 중복 값이 적은, 즉 카디널리티가 높은 컬럼을 인덱스로 선정하는 것이 좋습니다.   데이터베이스의 벤더, 버전, 스키마 구조 등과 같은 환경 조건마다 다르겠지만 일반적으로 조회 조건이 없거나 인덱스가 아닌 컬럼을 조건으로 조회한다면 조회 쿼리의 실행계획은 풀 테이블 스캔일 것입니다. 이런 경우 데이터가 적은 경우엔 괜찮겠지만, 데이터가 수백만 건이 넘는 경우라면 성능에 지장을 받게 됩니다.   실제로 하나의 잘못된 조회 쿼리로 인해 동시간대에 실행되는 같은 쿼리들이 성능에 영향을 받아본 경험이 있습니다. 인덱스를 타지 않고 조회되는 쿼리로 인해 슬로우 쿼리가 되었고 이는 데이터베이스 시스템 전체 성능에 영향을 주게 되었습니다. 올바른 컬럼을 선정하여 인덱스를 생성한 후 쿼리를 실행하니 실행 시간은 1초 이내로 줄어들게 되었습니다.   하지만 무분별하게 인덱스를 많이 생성하는 것이 좋은 것은 아닙니다. 무분별하게 불필요한 많은 인덱스를 생성할 시 데이터 핸들링에 있어 성능 저하를 가져올 수 있습니다. 또한 이미 언급했듯 인덱스는 조회 쿼리의 성능 향상과 삽입, 수정, 삭제 등 쿼리의 성능 저하를 맞바꾸는 것입니다. 따라서 상황과 스키마 구조에 따라 적절한 컬럼을 선택하여 인덱스를 생성하는 것이 좋습니다.     네트워크   HTTP와 HTTPS 프로토콜의 차이는 무엇인가?  먼저 HTTP는 Hyper Text Transfer Protocol의 약자로 WWW 환경에서 하이퍼링크와 같은 데이터를 송수신하는데 사용되는 통신 규약입니다. 주로 TCP 프로토콜이 사용되나 HTTP 3 버전 이후에는 UDP 프로토콜이 사용되고 있습니다. 그리고 이 HTTP 프로토콜에는 보안 취약점이 존재합니다. 서버와 클라이언트(브라우저) 간 전송되는 데이터가 암호화되지 않는다는 것입니다. 따라서 이를 보완하기 위해 나온 프로토콜이 HTTPS (HTTP + Secure)입니다. HTTPS 인증과 암호를 강화하기 위해 SSL/TLS 프로토콜을 사용하여 세션 데이터를 암호화합니다. HTTPS는 전자 상거래 등과 같이 보안이 중요한 경우에 사용됩니다.   HTTPS는 대칭키와, 공개키-개인키를 모두 사용합니다.   대칭키 방식     서버와 클라이언트 모두 같은 키(대칭키)를 사용하여 데이터를 암호화, 복호화합니다.   대칭키 하나로 암호화, 복호화를 모두 수행하기 때문에 데이터를 송수신하는 양측 모두 대칭키를 알고 있어야 합니다.   공개키-개인키 방식에 비해서 성능상 빠르나 외부에 대칭키가 노출되면 위험합니다.   공개키-개인키 방식     공개키와 개인키는 하나의 키 쌍이며 서버와 클라이언트 모두 각각 공개키와 개인키를 갖고 있습니다.   공개키는 외부에 공개하지만 개인키는 절대 외부에 공개하거나 노출되면 보안상 위험합니다.   특정 데이터를 공개키로 암호화할 경우 공개키의 쌍인 비밀키로만 복호화가 가능합니다.            반대로 비밀키로 암호화한 경우 비밀키의 쌍인 공개키로만 복호화가 가능합니다.           대칭키 방식보다 성능상 느립니다.   HTTPS는 이 방식들을 함께 사용해 각 방식의 단점을 상쇄하고 있습니다. 일반적으로 서버의 공개키에는 인증기관(CA)의 인증을 보장하는 전자서명(인증기관의 개인키로 암호화된 인증서)이 포함되어 있습니다. 따라서 서버는 이 인증서를 클라이언트(브라우저)에게 송신하고 클라이언트는 이 키를 인증기관의 공개키로 복호화하여 확인합니다. 클라이언트는 이후에 사용할 대칭키를 해당 인증서에 포함된 서버의 공개키로 암호화해 전송합니다. 이를 수신한 서버는 서버의 개인키를 이용해 클라이언트의 데이터를 복호화하여 클라이언트가 전송한 대칭키를 확보합니다. 이후부터는 서버와 클라이언트는 이 대칭키를 이용해 데이터를 주고 받습니다. 결론적으로 HTTP와 HTTPS의 차이는 보안성이라고 할 수 있겠습니다. 보안 절차로 인해 HTTPS가 HTTP보다 성능이 다소 떨어질 수 있으나 이는 최근에 사람이 느끼지 못할 정도입니다. 하여 보안적으로 중요한 데이터를 다룬다면 HTTP보다 HTTPS 프로토콜을 사용하는 것이 좋습니다.     REST API의 정의는? 그리고 REST API 설계시 고려사항은?  먼저 REST란 Representational State Transfer의 약자로 WWW 같은 분산 시스템 환경을 위한 소프트웨어 아키텍처 중 하나입니다. REST 아키텍처는 네트워크 아키텍처의 모음이라고 볼 수 있기 때문에 하이브리드 아키텍처라고도 불립니다. REST는 URI(URL, URN) 형태로 리소스(자원, 서비스되는 기능)를 제공하는 특성이 있습니다. 일반적으로 HTTP 프로토콜을 사용하나 반드시 HTTP 프로토콜을 사용할 필요는 없습니다. REST 아키텍처의 가이드 조건을 모두 만족한 상태를 RESTful이라고 하며 가이드 조건은 약 6가지가 있습니다.   REST 아키텍처의 특징(조건)     Server-Client 구조            서비스를 요청하는 클라이언트와 리소스를 제공하는 서버 구조로 이루어져 있습니다.           Stateless            콘텍스트와 무관하여 순서나 절차가 상관없습니다.           Cacheable            기존 웹 환경에서처럼 캐싱 처리를 할 수 있어야 합니다.           Layered Architecture System            외부에서는 서버의 레이어를 알 수 없습니다.       로드밸런서를 중간에 배치하는 등 서버 구조의 계층화를 통해 서버의 확장성과 유연성을 확보할 수 있습니다.           Uniform Interface            일관적인 인터페이스로 분리되어야 함을 뜻합니다.           Code on Demand(Optional - 필수 아님)            서버가 클라이언트가 실행 가능한 소스(로직)를 제공해 기능을 확장 시킬 수 있습니다.           API는 Application Programming Interface의 약자로 구현된 기능을 외부에서 사용할 수 있게 제공되는 인터페이스입니다. 정리하면 REST API는 REST 아키텍처의 가이드 형태를 따르는 API라고 할 수 있습니다. 가이드를 따르지 않는다면 REST API보다는 HTTP API에 더 가깝습니다. REST API는 리소스(URI), 행위(HTTP method), 표현(Representation) 구조로 이루어져 있습니다. REST API 설계를 위해서는 먼저 REST API 원칙을 준수해야 합니다.   REST 인터페이스(API) 원칙     자원의 식별 (Resource identification in request)            요청 내에 개별 자원이 식별 가능해야 합니다.           메시지를 통한 리소스의 조작 (Resource manipulation through representations)            메시지가 충분한 메타데이터를 포함한 경우 메시지를 통하여 자원을 조작합니다.           자기 서술적 메시지 (Self-descriptive message)            각 메시지는 자신을 처리하는 정보를 충분히 포함해야 합니다.           애플리케이션의 상태에 대한 엔진으로서 하이퍼미디어 (HATEOAS)            Hypermedia As The Engine Of Application State       연관된 리소스의 자원 상태를 제공합니다.           위 원칙을 기반으로 REST API 설계 시 고려 사항은 꽤 많은 양이라 간략하게 말씀드립니다.     URI Rules            URI는 소문자를 사용해야 하고, 명사를 사용하는 것이 바람직합니다.       또한 ‘_’ 대신 ‘-‘를 사용하는 것이 좋습니다.           HTTP Headers            Content-Location를 사용해 실제 위치를 명시하거나 HATEOAS를 사용합니다.       Content-type은 application/json를 제공합니다.       비정상적인 요청이 많은 경우 Retry-After를 사용해 429(Too Many Request)를 응답합니다.           HTTP Method            기본적으로 POST, PUT, GET, DELETE 메서드를 제공합니다.           HTTP Status Code            응답시 API 처리 결과에 따라 알맞는 HTTP 상태 코드를 담아 반환합니다.           HATEOAS (Hypermedia As The Engine Of Application State)            리소스의 상태 전이 링크를 제공합니다.           Paging, Ordering, Filtering, Field-Selecting            페이징, 정렬, 조건 필터, 특정 컬럼만 조회 등과 같은 기능을 제공합니다.           Versioning            URI 버저닝을 합니다.           기타   REST API를 사용하는 것은 여러 장점이 있습니다. 일반적으로 HTTP 프로토콜을 사용하기 때문에 어렵지 않게 사용할 수 있고 콘텍스트를 보관할 필요가 없습니다. 또한 xml, json 등 어떠한 representation 형태로 표현이 가능합니다. 하지만 공식적인 가이드를 제공하지 않고 강제성을 띠지 않기 때문에 명확한 기준점, 표준이 없습니다. 이로 인해 프로젝트에서 API 설계에 다양한 사람들이 투입되거나 명확한 가이드라인을 규정하지 않는다면 다소 난항을 겪게 됩니다. API는 말그대로 외부에 공개되는 인터페이스로써 한 번 공개되면 변경이 어렵기 때문에 처음부터 명확한 기준을 가지고 설계가 이루어져야 합니다.     프록시 서버의 정의와 역할은?  프록시 서버는 클라이언트가 외부 통신망, 네트워크 서비스에 접속할 때  간접적으로 접속하거나, 또는 부가 기능 수행이나 대리 수행해주는 프로그램을 내포하는 서버를 말합니다. 혹은 포괄적으로 그 수행 프로그램, 시스템을 표현하기도 합니다. 일반적으로 데이터를 대신 전달하는 기능을 수행하며 보안, 성능 향상 등의 목적을 가지고 있습니다. 그래서 요청 리소스 캐싱 기능, 특정 IP 영역대 차단, 트래픽 분산 등의 기능을 수행하는 경우가 많습니다.   이 프록시 서버의 종류로는 포워드 프록시 서버와 리버스 프록시 서버가 있습니다. 일반적으로 요청 방향에 따라 나뉘고 있습니다. 내부 네트워크에서 외부 네크워크로 나가기 전에 거치는 프록시 서버가 포워드 프록시 서버이며 외부 네트워크에서 내부 네트워크로 들어오기 전에 거치는 프록시 서버가 리버스 프록시 서버입니다.   포워드 프록시 서버는 데이터를 캐싱하여 요청에 대한 처리를 할 수 있습니다. 그리고 외부 네트워크로부터 내부 클라이언트(호스트)의 정보를 숨기는 역할도 수행할 수 있습니다. 리버스 프록시 서버는 외부네트워크에서 접근시 유효한 IP 영역대 인지 확인하는 보안 기능을 수행할 수 있습니다. 또한 대규모 트래픽을 감당해야 하는 서비스인 경우 들어오는 요청 트래픽을 감별하여 부하를 각 서버에게 분산처리해 줄 수 있습니다.   이처럼 프록시 서버는 네트워크 송수신시 클라이언트와 서버의 기능을 보완하거나 안정적인 상태를 보장할 수 있도록 도와주는 역할을 하고 있습니다.     설계 원칙, 프로그래밍 패러다임 (OOP, FP)   SOLID 원칙이란?  객체지향 디자인을 위한 원칙 중 1개입니다. 총 5가지로 이루어져 있습니다.      단일 책임 원칙 (Single Responsibility Principle)            클래스는 단 한 가지의 책임만을 가져야 하며 수정 이유는 단 한 가지여야 한다는 원칙입니다.       책임 분산 시 유연하고 깔끔한 코드를 구현할 수 있습니다.           개방 폐쇄 원칙 (Open Close Principle)            개체는 확장엔 열려있고 수정엔 닫혀 있어야 한다는 원칙입니다.       말 그대로 수정시 영향을 최소화하고 확장은 쉬워야 합니다.           리스코프 치환 원칙 (Liskov Substitution Principle)            서브타입은 그것의 수퍼타입으로 치환 가능해야 한다는 원칙입니다.       서브타입은 수퍼타입의 기능을 변경하지 않고 확장만 하는 수행해야 합니다.           인터페이스 분리 원칙 (Interface Segregation Principle)            클라이언트가 자신이 사용하지 않는 메서드에 의존하도록 강제되어선 안 된다는 원칙입니다.       따라서 인터페이스를 책임별로 잘게 분리하여야 합니다.           의존 관계 역전 원칙 (Dependency Inversion Principle)            상위 수준 모듈이 하위 수준의 모듈에게 의존하지 않아야 한다는 원칙입니다.       구체화에 의존하지않고 추상화에 의존해야 합니다.           실제로 해당 원칙의 중요성을 느끼게 된 경험이 있습니다. 당시 언론 매체별 기사 데이터를 특정 데이터 형식으로 파싱하는 기능을 구현했습니다. 이때 Article이라는 객체에 파싱 기능이 구현되어 있고 파싱 후에 데이터를 갖고 있는 구조 였습니다. 하지만 시간이 지날수록 매체가 늘어나기 시작했고, 매체마다 다른 파싱작업이 필요했습니다. 문제는 이 구조가 위 솔리드 원칙에서 단일 책임 원칙과 개방 폐쇄 원칙을 지키지 못하고 있었습니다. 기존에는 파싱 작업 내에서 기사 특성을 분기 처리하여 파싱하는 방식으로 처리되어 있었습니다. 이로 인해 파싱 기능을 수정할 때 다른 기사의 파싱 작업까지 변경의 영향을 끼치는 인적 장애가 발생하곤 했습니다. 해결을 위해 솔리드 원칙에서도 단일 책임 원칙과 개방 폐쇄 원칙이 지켜지게끔 클래스 아키텍처를 수정하였고 Article이라는 기사 객체의 파싱 기능을 Parser 객체로 분리, 합성 구조로 구현했습니다. 변경 후부터는 유연하고 안정적인 구조가 되어 기능 수정 시에도 기존 기능이 영향을 받는 일이 없어졌습니다.   솔리드 원칙이 중요한 이유는 유연하고 안정적인 설계를 위해서입니다. 안전하면서도 빠른 기능 반영이 요구되는 애자일 프로세스 내에서라면 더욱 중요하다고 생각합니다. 물론 설계 원칙들을 상황과 구조에 따라 지키지 못하는 경우도 있습니다. 다만 가능한 경우 이러한 원칙을 지킨다면 유연하고 안정적인 설계에 도움이 된다고 생각합니다.     디미터 (디미테르) 법칙이란?  디미터 법칙은 협력 객체들의 경로를 제한하여 객체간 결합도를 낮추기 위한 법칙 중 하나입니다. 특정 객체의 메서드에서 호출할 수 있는 메서드를 논리적으로 제한하는 것이 이 법칙의 특징입니다.   객체 O의 메서드 m에서 호출할 수 있는 메서드의 종류     O 객체 자신(this)의 메서드   m 메서드가 생성한 객체의 메서드   m 메서드의 파라미터로 넘어온 객체의 메서드   O 객체가 필드로 가지고 있는 인스턴스 변수(객체)의 메서드   m 메서드에서 접근 가능한 전역 변수(객체)의 메서드   이 법칙 또한 다른 설계 원칙들과 마찬가지로 반드시 지키지 않아도 되나, 가능하면 지키는 것이 유연한 설계의 지름길입니다. 객체간 결합도가 높다면 특정 객체를 수정했을 때 영향을 받게 되는 객체들이 많아져 사이드 이펙트가 발생할 확률이 높아집니다. 더욱이 결합하는 객체가 인접한 객체가 아닌 경우 그 영향에 여파를 가늠하기 더 힘들어집니다. 따라서 처음 설계, 구현 시부터 디미터의 법칙을 지켜 거리가 먼 객체 간의 결합도를 최대한 낮추는 것이 바람직하다고 생각합니다.     CQRS 패턴이란?  CQRS은 Command Query Responsibility Segregation의 약자로 커맨드(명령)와 쿼리(조회)의 책임을 분산하는 아키텍처 패턴입니다. 커맨드와 쿼리를 분리하는 프로그래밍 원칙인 CQS에서 파생된 아키텍처 패턴이라는 설이 유력합니다. 여기서 커맨드는 데이터의 변경을 발생시키는 행위이며 쿼리는 데이터를 가져오는 행위입니다. 이 패턴에서 커맨드는 데이터 자체가 아닌 행위를 기반으로 해야 합니다. 그리고 쿼리는 데이터를 수정하지 않는 행위여야 합니다.   애플리케이션을 서비스하다 보면 시간이 지남에 따라 규모가 커지면서 도메인이 복잡해집니다. 이를 위해 커맨드와 쿼리를 분리하여 개발, 운영하는 아키텍처 패턴 적용을 생각하게 되는데 이 중 하나가 CQRS 패턴입니다. 애플리케이션 내에서 커맨드와 쿼리를 기준으로 도메인을 분리하여 구현 및 개발하는 방식입니다. 설계에 따라 데이터 저장소를 물리적으로 커맨드 트랜잭션 전용 저장소와 쿼리 전용 저장소를 나누어 구현하기도 합니다. 이런 경우 두 데이터 저장소의 일관성이 깨지기 때문에 데이터를 동기화 시켜주는 작업이 필요합니다. 일반적으로 RabbitMQ, kafka 같은 메시지 브로커를 통해 데이터 동기화 작업을 수행합니다.   물론 현대 서비스에서는 명령과 쿼리로 나누기 애매한 작업들이 있습니다. 또한 CQRS 아키텍처 패턴은 도메인 분리로 인해 기능적으로 안정적인 구현을 할 수 있으나 구현해야 되는 코드가 많아지고 더 많은 기술을 적용하여 관리해야 하는 등과 같은 단점도 지니고 있습니다. 따라서 무작정 해당 아키텍처 패턴을 적용하는 것이 아닌 수행하는 프로젝트의 도메인과 환경을 보고 도입 여부를 결정하는 것이 좋을 것입니다.    ","categories": ["Interview"],
        "tags": ["NextStep","Multi process & Multi thread","Java","Index","HTTP","REST API","Proxy server","SOLID","Demeter","CQRS"],
        "url": "/interview/next-step-interview/",
        "teaser": null
      },{
        "title": "[자기 소개 가이드] 개발자가 기술 면접에서 자기 소개하기",
        "excerpt":"들어가기 전에     해당 내용은 개인적으로 알아보거나 경험한 내용, 피드백을 취합한 내용이기에 정답이 아닌 의견입니다.   경험, 가치관, 자격 요건 등 기준에 따라 상반되는 의견도 존재할 수 있습니다.   면접자(구직자)의 기술 역량과 채용 공고의 자격 요건에 따라 내용과 순서가 달라질 수 있습니다.   해당 내용은 특별한 계기 없이도 언제든 수정될 수 있습니다.     유의사항     면접에서 맨 처음 진행되는 절차입니다.            물론 그 전에 아이스 브레이킹(긴장 되는 분위기 전환)을 위한 가벼운 질문이 나올 수 있습니다.       또한 자기 소개는 면접 진행 절차에 따라 생략될 수 있습니다.           면접에서 유일하게 면접자가 정확하게 사전 준비가 가능합니다.   자기 소개는 면접관이 질문(면접 진행)을 준비하는 시간이기 때문에 강조할 경력과 기술을 잘 정리해야 합니다.            자기 소개에 따라 면접의 방향(질문 리스트)이 정해질 수도 있습니다.             자기 소개 시간  주어진 시간에 맞춰 자신을 소개합니다.     보편적으로 3분 안팎으로 소개하나 기업에 따라 상이할 수 있습니다.   너무 길어지면 면접관과 면접자 모두에게 집중할 분위기가 형성되지 않습니다.            따라서 모든 내용을 핵심 포인트만 설명하며 최대한 간략하게 얘기합니다.             자기 소개 핵심 내용  일반적으로 최근 경력(기술 역량) 중 강조하고 싶은 내용을 위주로 소개합니다.     개인 성향, 가치관 등에 대한 소개를 요청하지 않는다면 자신의 경력 위주의 소개를 합니다.   경력 위주의 자기 소개시 이력서를 전반적으로 훑어보듯이 소개합니다.   구인 공고의 자격 요건에 맞는 기술 역량을 강조하여 소개 합니다.            어떤 프로젝트에서       어떤 기술을 사용하여       어떤 기능을 구현, 또는 어떤 장애를 처리하였으며       어떤 성과를 도출한 경험이 있다           정확한 용어, 문맥적으로 알맞은 어휘를 구사하여 구체적으로 표현해야 합니다.            일반적으로 잘 알려지지 않은 용어, 어휘 사용은 지양합니다.           성과를 설명할 때 정확한 수치나 객관적 지표를 기반으로 설명합니다.   강조할 기술 역량을 깊이 있게 알아야 하며, 뒷받침할 경험은 객관적 사실이어야 합니다.            이어지는 질문들이 자기 소개에 대한 꼬리물기 형태에 질문일 수 있습니다.             자기 소개 대본 작성시 장점  미리 대본을 작성하여 말하는 연습을 해보는 것이 좋습니다.      미리 준비 하지 않고 즉흥적으로 하는 경우         강조할 기술 역량의 방향이 잘못되는 경우가 있습니다.     버벅거리거나 끊긴다면 면접 전체 흐름을 깨뜨릴 수 있습니다.       미리 대본을 작성하여 말하는 연습을 하는 경우         자신이 어필할 기술 역량, 프로젝트 경험을 한 번 더 되돌아 보게 됩니다.                필요하다면 강조 기술을 위해 이력서를 수정하기도 합니다.                 준비하기 전보다 상대적으로 긴장을 줄일 수 있습니다.        대본을 통해 연습하는 경우 유의사항     대본이 반드시 격식을 지킬 필요는 없습니다.            적정선을 지킨다면 구어체로 작성하는 것이 머릿속에 담기 편할 수 있습니다.           설명한다 또는 대화한다라는 느낌으로 매끄럽게 전달되는 것이 중요합니다.            면접은 단순히 외운 것을 읊는 시험이 아닙니다.           전부 외우려 노력하지 말고 큰 맥락에서 강조할 내용을 설명하는 것에 초점을 맞춥니다.            오히려 대본 전체를 외우다가 까먹는다면 더 어려운 상황에 빠질 수 있습니다.       따라서 중요하지 않는 내용을 생략해 분량을 조절합니다.          ","categories": ["Interview"],
        "tags": ["Introduce","Guide"],
        "url": "/interview/introduce-guide/",
        "teaser": null
      },{
        "title": "[이력서 가이드] 개발자 이력서 작성 가이드",
        "excerpt":"들어가기 전에     해당 내용은 개인적으로 알아보거나 경험한 내용, 피드백을 취합한 내용이기에 정답이 아닌 의견입니다.   경험, 가치관, 자격 요건 등 기준에 따라 상반되는 의견도 존재할 수 있습니다.   면접자(구직자)의 기술 역량과 채용 공고의 자격 요건에 따라 내용과 순서가 달라질 수 있습니다.   해당 내용은 특별한 계기 없이도 언제든 수정될 수 있습니다.     이력서를 작성하기 전에   이력서란?     이력서는 구직자가 취직을 위해 제출하는 구직자의 정보, 기술 역량 등이 기록된 문서입니다.            사실 개발자의 이력서는 resume보다 CV(Curriculum Vitae)에 가깝습니다.           간단하게 말하면 구직자 판매를 목적으로 한 광고 전단지입니다.            따라서 이력서 작성 전에 구직자의 어떤 역량을 홍보하여 기업을 설득할 수 있는지 확인이 필요합니다.             이력서 파일 포맷     이력서 파일은 일반적으로 pdf로 변환하여 제출하도록 합니다.            강제는 아니지만 다른 확장자 파일은 뷰어가 없다면 호환성 문제가 있을 수 있습니다.       최근에는 URL 형태로 이력서, 첨부 자료(포트폴리오)를 제출하기도 합니다.             이력서 작성 시점     이력서는 항상 채용 공고에 맞춰 새로 작성해야 합니다.            자격 요건에 따라 이력서의 내용, 순서 등이 달라지기 때문입니다.           이와 별개로 항상 자신만의 이력서를 관리하는 것이 좋습니다.            자신만의 이력서를 갖고 있다면 채용 공고마다 새 이력서 작성이 쉬워집니다.       이력서의 갱신 주기는 짧을수록 좋기 때문에 항상 관리, 갱신하도록 합니다.                    이직 의사가 없을 때도 관리하길 권합니다.                             이력서 검토자     일반적으로 구직자(개발자)의 이력서 검토는 대부분 현직 개발자가 하게 될 것입니다.            개발자들은 본 업무 때문에 이력서를 보는데 대략 5~10분의 시간 정도만을 할애하게 됩니다.       그래서 잘 읽히게 작성하여 짧은 시간 내에 나의 역량을 최대한 많이 보여줘야 합니다.                    이것은 단순히 내 경험과 지식을 많이 나열하라는 뜻이 아닙니다.           요구되는 자격 요건에 부합하는 나의 역량을 잘 분별해야 한다는 뜻입니다.                       이로써 그들이 나에 대해 흥미를 갖도록 만들어야 합니다.             이력서 양식     자신의 역량을 제일 잘 어필할 수 있는 양식이 어떤 형태인지 고민해 보아야 합니다.            기존에 딱딱한 이력서 양식은 개발자의 기술 역량을 강조하기 어렵습니다.           일반적으로 정해진 양식이 없어 잘 읽히는 이력서라면 어떤 양식이라도 무방합니다.   간결하며 내용이 돋보여 기술 역량을 강조할 수 있는 양식을 선택하도록 합니다.            쉽게 읽히는 폰트와 크기를 선택해야 합니다.                    기울기는 가독성을 이유로 되도록 사용하지 않는 것을 권합니다.                       폰트의 굵기와 색상, 밑줄 등은 되도록 조금만 사용, 남발하지 않도록 합니다.                    강조 목적으로 너무 많이 사용하면 오히려 읽기가 더 어려워집니다.                       내용에 따라 글머리 기호를 활용하는 것도 가독성을 위한 좋은 예시입니다.       다채로운 색상과 불필요한 특수문자, 이모지 사용 등 화려한 양식은 지양합니다.           기존에 잘 작성된 다른 분들의 이력서를 참고하면서 자신만의 이력서 양식을 만들도록 합니다.     이력서 분량     일반적으로 정해진 분량은 없으며 내용이 알차고 쉽게 읽힌다면 분량 자체는 크게 의미가 없습니다.   분량보다 더 중요한 것은 채워져 있는 내용입니다.   분량은 가볍게 훑어보기 좋은 정도면 충분하니 내용의 퀄리티를 고민합시다.            다만 word(pdf)와 같은 형식을 기준으로 대략 5~10페이지 정도로 작성하는 것을 권합니다.       너무 짧으면 볼 내용이 없고 너무 길면 강조 포인트를 찾기 어려워집니다.           같은 내용도 폰트 크기에 따라 분량이 달라지기 때문에 1~2페이지 차이는 무관합니다.   어떠한 목차라도 자격 요건에 부합하는 역량만을 작성하여 분량을 줄이도록 합니다.            요구되는 역량과 관계가 없거나 능숙하지 못한 역량을 빼도록 합니다.             이력서 작성 순서          기본 정보     자기 소개     주력 스킬(기술 역량)     경력 사항                재직 이력         수행한 프로젝트 이력 (프로젝트 경험)                 그 외 활동                오픈 소스 프로젝트 or 사이드 프로젝트         기술 저서 출판 or 세미나 발표 or 강연/강의         수강한 강의         기타                 학력 or 자격증      자격 요건이나 상황에 따라 기재 정보를 추가, 생략할 수 있습니다.     그 외 이력서 작성시 유의사항     모든 내용은 개발자의 관점에서 작성해야 합니다.            일반적으로 내 이력서를 읽는 사람도 나와 같은 개발자일 확률이 높습니다.           채용 공고의 기술 자격 요건, 포지션 등 조건을 꼼꼼하게 살펴봐야 합니다.            나의 역량을 해당 조건에 알맞게 녹여낸 이력서를 만들어야 합니다.           거짓말은 일절 하지 않으며 작성 내용은 반드시 증명 가능해야 합니다.            예를 들어 경험하지 않은 것을 경험한 것처럼 작성하는 행위는 하지 않습니다.           어렵겠지만 구체적인 내용을 간결하게 작성해야 합니다.   공식적이고 정확한 어휘를 구사하도록 합니다.            표준어를 사용하고 은어, 비속어, 신조어 등은 사용을 지양합니다.       애매하고 추상적인 표현보다 정확하고 구체적인 표현을 사용하도록 합니다.           축약어를 사용할 때는 되도록 명확하거나 널리 알려진 축약어를 사용합니다.            그 외에는 축약어가 처음 나오는 곳에 전체 뜻을 풀어 써주도록 합니다.                    예 : SEO -&gt; SEO(search engine optimization) or 검색엔진 최적화                           다른 부분보다 경력 사항 비중이 가장 높아야 합니다.     기본 정보          이름     메일주소     전화번호     Github 주소     기술 블로그 주소      유의사항     상위 정보 이외에 나이, 자택 주소 등 자신의 역량과 무관한 정보는 빼도록 합니다.   깃허브, 기술 블로그 주소는 개발자의 역량 판단에 참고가 되는 자료일 뿐 필수가 아닙니다.            기재된 깃허브/블로그가 관리 되지 않는 상태라면 의미가 없습니다.       다시 말해 기재하지 않는다고 해서 감점 요인이 되는 것은 아닙니다.       하지만 개발자를 판단할 추가적인 자료, 지표가 되는 것 또한 사실입니다.       따라서 여유가 된다면 운영/관리하는 것을 권합니다.             자기 소개     자격 요건에 맞춰 나를 소개         간결하게 1~2문단, 전체 5~10줄 미만의 분량으로 작성합니다.     자신의 경험을 기반으로 주력 기술과 앞으로 어떤 개발자를 지향하는지를 설명합니다.     개발 업무에 적용시킬 수 있는 자신만의 차별화된 장점을 강조합니다.                꾸준한 학습 태도, 의사소통(협업 능력), 외국어 능력 등                  유의사항     모든 내용은 증명 가능한 내용만을 작성하도록 합니다.            꾸준한 학습 태도를 강조하였다면 학습했던 이력들을 확인할 수 있어야 합니다.           개발과 무관한 사적인 내용은 의미 없이 분량만 늘리니 피하도록 합니다.     주력 스킬 (보유한 기술 역량)     기재할 기술         주력으로 사용하는 전문가 수준의 기술     이해도가 깊어 누군가에게 자신 있게 설명이 가능한 수준의 기술     이에 관련된 업무, 응용문제들을 문제없이 해결이 가능한 수준의 기술       기재를 고민해봐야 하는 기술         단순히 1~2번 사용해 본 기술                꼭 적어야 한다면 다른 주력 스킬에 강조 표시를 해두는 것이 좋습니다.                 다룬 지 너무 오래되어 기억이 잘 안 나는 기술                해당 내용을 상기, 복습 후에 적는 것이 좋습니다.                 자격 요건에 해당하지 않거나 별 메리트가 없는 기술                큰 의미 없이 장황하게만 보이는 경우가 대부분입니다.                  유의사항     사용한 API는 기재를 지양하고 포괄적인 스킬을 작성할 것을 권합니다.            다른 누군가가 구현한 것을 그저 사용한 것에 불과합니다.       따라서 Bootpay API 등은 작성하지 않는 것을 권합니다.           가능하면 다음과 같이 카테고리를 분류해 작성하는 것을 권합니다.            예를 들어 FrontEnd/BackEnd/DevOps/Cloud/Collaboration 같은 분류를 추천합니다.           기술 스택은 단순히 많이 작성하는 것이 능사가 아닙니다.            단순히 경험 기술을 많이 나열한다고 해서 그 누구도 잘한다고 생각하지 않습니다.       이 경우 면접 시 모든 스킬에 대해 깊이 있는 답변을 하지 못한다면 오히려 감점입니다.       따라서 깊이 있는 답변이 가능한 기술만을 남겨두는 것이 바람직합니다.           해당 기술의 역량적 수준을 표시하지 않습니다.            자체적으로 평가한 수준을 아무도 믿지 않습니다.       다만 기업에서 자체 역량 수준을 요구하는 경우에만 기재합니다.                    특정 대기업에서도 지원 이력서에 자체 역량 수준을 요구하는 경우가 있었습니다.                           기술의 메이저 버전은 상황에 따라 기재 여부를 결정합니다.            만약 기재한다면 해당 버전의 특징을 모두 숙지하도록 합니다.           작성한 내용은 경력 사항이나 그 외 활동에서 증명되어야 합니다.     경력 사항 (경력 기술서)  이력서에서 제일 중요한 부분이며 재직 이력과 프로젝트 이력 모두 최신순으로 작성합니다.   재직 이력          소속 기업                기업명을 간략하게 작성합니다.                 근무 기간                일반적으로 입사~퇴사 순으로 일자를 연월 형식으로 작성합니다.         근무 개월 수는 상황에 따라 기재 여부를 결정합니다.                 주요 업무                자신의 역량이 드러난 프로젝트와 업무를 강조하여 간결하게 작성합니다.                 사용 기술                재직 중 사용했던 기술들을 기재합니다.         채용 기업에 따라 필수 기재 요소가 아닐 수 있습니다.                  유의사항     되도록 모든 재직 이력을 1~2페이지 분량으로 간략하게 작성합니다.            경력이 적으시다면 1페이지 내로 작성하길 권합니다.           꼭 모든 이력을 다 기재할 필요는 없습니다.            예를 들어 수습 기간내에 퇴사하여 특별한 수행 업무가 없다면 생략 가능합니다.           재직 이력의 내용 또한 상황에 따라 기재 내용을 추가, 생략할 수 있습니다.            예를 들어 퇴직(이직) 사유 등은 상황과 본인 판단에 따라 기재 여부를 결정합니다.           기업의 경력 인정 조건에 따라 기재 가능한 경력이 달라 꼼꼼하게 확인해야 합니다.            예를 들어 다음과 같은 조건들이 있을 수 있습니다.                    프리랜서 경력은 기재 불가 또는 인정하지 않는 경우           경력 증명이 불가능한 경우           수습 기간에만 재직한 경우                             수행한 프로젝트 이력     프로젝트명, 프로젝트 기간, 소속 기업명         프로젝트명은 쉽게 이해 가능한 이름을 사용합니다.       개발 환경         업무 수행 시 사용한 OS, 플랫폼, 언어, 프레임워크(라이브러리) 등을 작성합니다.       프로젝트 설명         어떤 프로젝트인지 정확한 용어를 사용하여 간단하게 설명합니다.       담당 업무         어떤 기술을 사용하여 어떤 방식으로 처리했고 어떤 성과를 이뤄냈는지 작성합니다.                추상적인 표현을 지양하고 정확한 용어를 사용하여 구체적으로 표현합니다.         이때 작성한 모든 내용에 대해서 깊은 이해도가 필요합니다.                 사용 기술명은 상황에 따라 생략하기도 합니다.                예 : 사용 기술이 강조할 특징이 없는 경우                 성과는 정확한 수치로 표현하는 것이 좋습니다.                프로젝트의 성과보다는 기술적인 성과를 작성합니다.         비약적인 성과가 아니거나 큰 메리트가 없는 경우 생략하기도 합니다.                   결과 or 성과         강조할 성과가 있다면 담당 업무에 함께 작성하지 않고 별도로 빼내 작성할 수 있습니다.     최대한 정확한 수치를 통해 나타내는 것이 좋습니다.       문제 해결 사례 or 배운 점         자격 요건과 관련된 역량을 강조하기 위해 작성하는 부분입니다.                반드시 작성하지 않아도 되나 강조할 것이 있다면 간결하게 작성하도록 합니다.                 기술적인 측면에서 문제 상황과 해결 방법, 배운 점을 작성합니다.                상황에 따라 협업 능력, 위기 대처 능력 등 소프트스킬을 강조하는 경우도 있습니다.                 내용을 대체할 링크를 삽입할 수도 있습니다.                다만 링크를 보지 않는 경우도 많으니 간략하게라도 작성해두면 좋습니다.                   기타         추가로 다음 링크(성과물)들을 첨부할 수 있습니다.                구현한 기능, 플랫폼, 서비스 페이지         사용 기술에 대한 특징 및 사용법, 이슈 등을 작성한 페이지                  유의사항     프로젝트 경험을 의미하며 이력서에서 가장 중요한 부분이니 내용적으로 검토합니다.            해당 부분은 기술 면접까지 고려하여 작성해야 합니다.       따라서 정말 필요한 경력인지, 어필했을 때 메리트가 있는 기술인지 고민이 필요합니다.           자격 요건에 알맞는 기술을 사용한 프로젝트를 최상위에 작성하여 강조하도록 합니다.            프로젝트의 개수는 중요하지 않습니다.       자격 요건에 부합하는지와 내용의 퀄리티가 중요합니다.           팀원이 수행한 업무를 스스로 한듯이 포장하지 않아야 합니다.            간접 경험과 직접 경험은 반드시 티가 나게 되어 있습니다.             그 외 활동  경력 외 역량과 학습 태도, 개발에 대한 열정 등을 드러내는 것이 목적          다음과 같은 상황에서 작성합니다.                해당 부분 자격 요건을 경력만으로 증명하기에 부족한 경우         경력 이외 어필이 되는 활동인 경우                 해당 부분은 경력 사항보다 강조되지 않아야 합니다.                단지 지원자의 관심사, 코딩 스타일, 실력 판단 등의 도움이 되는 참고 자료일 뿐입니다.                 자격 요건을 증명할 경력이 많다면 작성하지 않아도 무방합니다.     만약 작성한다면 깃허브, 기술 블로그 또는 면접에서 증명할 수 있어야 합니다.      오픈소스 프로젝트 or 사이드 프로젝트     경력 사항과 분리하여 작성하는 것이 좋고 양식은 비슷하게 작성하여도 무방합니다.   오픈소스 프로젝트의 기여한 경험이나 업무 외적으로 개발한 사이드 프로젝트를 작성합니다.            자격 요건과 관련이 있으면 더욱 좋습니다.             기술 저서 출판 or 세미나 발표 or 강연/강의     출판한 저서, 세미나 또는 강연 경험에 대해 작성합니다.            콘텐츠 내용, 배운 점 등을 간략히 서술하거나 증명할 링크를 삽입합니다.             수강한 강의 (교육)     그동안 학습한 내용 중 자격 요건과 관련된 내용만을 작성합니다.            어떤 점을 배웠는지, 어떤 프로젝트에 어떻게 적용했는지 등을 설명합니다.             학력 / 자격증     최종 학력            대부분에 기업은 기업 내 연봉 테이블 등을 이유로 최종 학력을 요구하는 경우가 많습니다.       학점은 요구되는 경우에만 작성해도 무방합니다.           자격증            개발 직무와 자격 요건에 관련된 자격증만을 작성합니다.       자격증 발급 일자, 자격증명, 발급 기관 등을 명시합니다.       정보처리기사나 AWS 자격증과 같이 자격 요건, 업무에 관련이 있다면 명시하는 것이 좋습니다.                    다만 일반 개발 관련 자격증은 크게 의미가 없는 경우가 많아 보편적으로 생략해도 무방합니다.                             검토  모두 작성하였다면 전체적으로 다음을 확인합니다.     전반적으로 일관된 문맥을 갖고 있어 매끄럽게 읽히는가?            없어도 되는 내용, 표현, 어휘는 없는가?           전체 분량이 적당한가?   경력 사항이 다른 사항보다 분량이 더 많고 내용이 강조되었는가?            자격 요건에 따라 내용의 순서가 재배치될 필요가 없는가?           올바른 맞춤법을 사용하였는가?            띄어쓰기, 오타 등 오탈자는 없는가?           첨부한 링크는 접속이 잘 되는가?   주변 사람들의 첨삭/피드백을 받았는가?  ","categories": ["Resume"],
        "tags": ["Curriculum Vitae","Guide"],
        "url": "/resume/guide/",
        "teaser": null
      },{
        "title": "[DDD] DDD START! 정리",
        "excerpt":"내용 정리     유튜브 : DDD START! 도메인 주도 설계 구현과 핵심 개념 익히기 (최범균)   영상 출처   정의  DDD(Domain Driven Design) - 도메인 주도 설계란?     설계 방법론 중 하나로 비즈니스 도메인별로 설계하는 방법   특징   MSA와 관계     MSA의 특성이 Bounded Context를 구성 또는 언어의 경계를 찾는데 도움을 줌   MSA(Micro Service Architecture)의 특성     서비스로서 컴포넌트화            독립 배포 -&gt; 서비스의 응집도(경계) 높아짐       명시적 인터페이스 -&gt; 공개 인터페이스           비즈니스 수행에 따른 구성            Conway 법칙                    우리가 만드는 서비스(시스템 구조)는 조직(기업)의 형태를 따라가게 됨                           분산화된 데이터 관리            DB가 하나라면 조인 쿼리를 통해 데이터를 가져오게 됨                    굳이 컴포넌트 서비스 엔드포인트를 호출하지 않으려 함                       DB의 물리적, 논리적 분리를 통해 도메인(모듈, 서비스 등) 경계 구분           진화하는 설계            서비스별 독립적인(목적, 빈도 등) 변경(교체, 업그레이드)           프로젝트가 아닌 제품   똑똑한 엔드 포인트와 더미 파이프   분산화 거버넌스   인프라 자동화   장애 방지 설계   Event Sourcing &amp; Aggregate     상태 변화 증분 = 이벤트            증분 누적 -&gt; 마지막 상태           이벤트 소싱     애플리케이션의 모든 상태 변화를 순서에 따라 이벤트로 보관            이벤트의 순서를 따라 실행해보면 최종 상태를 획득하게 됨           도메인 객체와 이벤트 소싱     도메인 객체 조회            저장된 이벤트로부터 도메인 객체 생성           도메인 객체 변경            모든 상태 변화에 대한 이벤트를 저장           일관성의 기준인 애그리거트 단위로 이벤트 소스를 생성            애그리거트(Aggregate)의 경계를 찾는데 도움을 줌           이벤트 구성     구성            애그리거트 타입       애그리거트 식별자       버전       이벤트 타입       이벤트 시간       증분(변경) 내역(payload)           이벤트 구분(unique idx)            애그리거트 타입, 애그리거트 식별자, 버전           애그리거트   애그리거트 조회   리포지토리  public class OrderRepository {      public Order findById(String orderId) {         List&lt;Event&gt; events = eventsStore.select(Order.class, orderId);                  if (events.isEmpty()) {             return null;         }                  Order order = new Order();         for (Event event : events) {             order.handle(event);         }                  addUOW(order); // Unit Of Work - 트랜잭션 범위에 Order 삽입         return order;     } }   애그리거트는 이벤트 반영  public abstract class Aggregate {     private Integer version;          public void handle(Event event) {         this.version = event.getVersion();         Events.handle(this, event);     } }   public class Order extends Aggregate {      public void on(OrderPlacedEvent event) {         this.lines = event.getOrderLines();         this.shippingInfo = event.getShippingInfo();     }          public void on(ShippingInfoChangedEvent event) {         this.shippingInfo = event.getShippingInfo();     }          public void on(ShippedEvent event) {         this.state = SHIPPED;     } }   애그리거트 변경   애그리거트에서 이벤트 발생  public abstract class Aggregate {     List&lt;Event&gt; uncommittedEvents;          public void apply(Event event) {         // 커밋되지 않은 이벤트 목록에 저장         addUncommittedEvent(event);         // 이벤트 적용         handle(event);     }          public List&lt;Event&gt; getUnCommittedEvent() {         return uncommittedEvents;     } }   public class Order extends Aggregate {          public void cancel() {         // 바로 상태 변경을 하지 않고, 상태 변경 이벤트를 생성해 상위에 전달         ...         OrderCanceledEvent event = new OrderCanceledEvent(getId(), version + 1);         super.apply(event);     } }   트랜잭션에서 이벤트 저장  public class CancleOrderService {          @Transactional     public void cancel(String orderId) {         Order order = orderRepository.findById(orderId);         checkNull(order);         order.cancel();     } }   class TransactionalHandler {          public void commit() {         // uncommitted 목록에 있던 모든 이벤트를 읽어 이벤트 스토어에 모두 저장         List&lt;Aggregate&gt; aggs = getAllUOW();         for (Aggregate agg : aggs) {             eventStore.append(agg.getClass(), agg.getUncomittedEvents());         }     } }   애그리거트 생성   애그리거트 생성자 : 생성 이벤트 발생  public class Order extends Aggregate {      public Order(...) {         ...         OrderCreatedEvent event = new OrderCreatedEvent(getId(), lines, shippingInfo, 1);         super.apply(event);     } }   public class PlaceOrderService {          @Transactional     public void cancel(String orderId) {         Order order = new Order(...);         repository.save(order);     } }   이벤트 소싱과 유지보수   새로운 데이터 추가  public class Order extends Aggregate {     private String note;          public Order(...) {         ...         OrderCreatedV2Event event = new OrderCreatedV2Event(...);         super.apply(event);     }          public void on(OrderCreatedEvent event) {         ...         this.note = \"\";     }          public void on(OrderCreatedV2Event event) {         ...         this.note = event.getNote();     } }      없어지는 것            DB 작업 일정       매핑 설정 변경           이벤트 소싱 적용한 애그리거트     임피던스 미스매치(impedance mismatch) 없음            코드의 도메인 모델과 DB의 데이터 모델의 불일치 간극을 줄이는 작업이 필요 없음           애그리거트 간 참조는 ID            객체 레퍼런스보다는 ID 참조           비선점 잠금            낙관적 잠금(Optimistic lock)이 자연스럽게 적용           성능     단일 애그리거트 조회 -&gt; 스냅샷            이벤트가 많아지면 이벤트의 개수 등을 기준으로 스냅샷을 저장하여 조회           복합 조회 -&gt; CQRS   SQL(ORM) vs 이벤트 소싱     변화되는 것            적용 전 (RDBMS/ORM)                    메인 객체 로딩                            SQL : Select 쿼리               ORM : 프레임워크가 Select 쿼리 실행(매핑 설정을 이용)                                   메인 기능                            SQL : 서비스 클래스               ORM : (일부) 엔티티 클래스                                   상태 변경 반영 (데이터 변경)                            SQL : Insert/Update/Delete 쿼리               ORM : 엔티티 프로퍼티를 변경하면 ORM 프레임워크가 알맞은 쿼리 실행                                               적용 후                    메인 객체 로딩                            이벤트로부터 도메인 객체 생성               도메인 객체의 이벤트 핸들러를 이용해 상태 변경 반영                                   메인 기능                            도메인 객체가 수행               상태 변경을 위한 이벤트 생성                                   상태 변경 반영 (데이터 변경)                            도메인 객체가 발생한 이벤트를 저장소에 보관                                                   장점     DB에 의존적이지 않은 도메인 코드 구현            테이블, ORM 기술의 제약에서 벗어남           기능 변경            하위 호환 처리가 상대적으로 쉬움       이벤트로부터 완전히 새로운 도메인 객체의 생성도 가능           버그 추적 용이            이벤트를 차례대로 검사하면서 버그 원인 추적 가능           객체 지향/DDD와 좋은 궁함            복잡한 도메인을 객체 지향적으로 구현하기에 좋음           CQRS와 좋은 궁합            조회 관련 코드를 도메인에서 분리       조회 모델 분리로 조회 성능 향상 가능           단점     익숙하지 않음            기존에는 SQL(DB 데이터 중심) 개발 성향이 다수           단순 모델에는 적합하지 않음            구현이 복잡해짐           도구 부족            이벤트 소싱과 CQRS 지원 프레임워크 부족       Java Axon 프레임워크           운영시 어려움            이벤트 데이터만으로는 최신 상태의 빠른 확인 불가능       CQRS 필수           SAGA     여러 하위 트랜잭션 집합으로 구성된 LLT            LLT : Long Lived Transaction       단위 실행 단위           각 하위 트랜잭션은 단독 트랜잭션            따라서 하위 트랜잭션 단위로 일관성 보장           각 하위 트랜잭션은 서로 연관   하위 트랜잭션 실패시, 보상 트랜잭션            일부만 성공해도 끝나지 않음           Long running process     상황, 문맥 등에 따라 SAGA와 동일한 개념으로 보는 경우도 있음   길게 실행되는 프로세스/트랜잭션 특징     여러 개의 작은 프로세스(트랜잭션)로 구성   하위 프로세스가 순서대로 실행되지 않을 수 있음   여러 모듈/서비스가 (비동기로) 엮임   한 트랜잭션이 아닐 수 있음   실패는 롤백 대신 보상(compensation)으로 처리   프로세스 매니저  중계, 프로세스 상태 보관, 지시 및 알림      여러 애그리거트/외부 시스템이 엮이는 건 프로세스의 흐름 제어            각 구성 요소 간의 메시지 라우팅이 주된 역할           프로세스의 상태 보관   비즈니스 로직은 개별 구성 요소에서 처리   구현     특정 이벤트에 SAGA/프로세스 매니저 시작   수신한 이벤트에 따라 다음 기능 실행            실패시 후속 보상 기능 실행           전체 프로세스가 끝나면 SAGA/프로세스 매니저 종료   상태 존재 -&gt; 프로세스별 인스턴스   에어카텔 상품 구매 예시  public class BookingProcessManager {     private BookingId bookingId;     private BookingState hotelState;     private BookingState airState;     private BookingState carState;          public void handle(BookingCreatedEvent event) {         this.bookingId = event.getBookingId();         sendBookingRequest();     }          public void handle(HotelBookedEvent event) {         hotelState = BookingState.BOOKED;         notifyIfAllBooked();     }          private void notifyIfAllBooked() {         if (hotelState == BOOKED &amp;&amp; airState == BOOKED &amp;&amp; carState == BOOKED) {             notifyBookingCompletion();         }     } }   실패 보상 처리   에어카텔 호텔 예약 실패 예시  public class BookingProcessManager {     private BookingId bookingId;     private BookingState hotelState;     private BookingState airState;     private BookingState carState;          public void handle(HotelBookingFailedEvent event) {         cancelAirBooking();         cancelCar();     }          private void cancelAirBooking() {         if (airState == BOOKED) {             cancelAirBooking();         } else {             airState = CANCEL_REQUIRED;         }     }          public void handle(AirBookedEvent event) {         if (airState == CANCEL_REQUIRED) {             cancelAirBooking();         } else {             airState = BOOKED;             notifyIfAllBooked();         }     } }   필요한 것     SAGA/매니저 상태 영속화            상태가 유실되지 않아야 함           이벤트 -&gt; 해당 SAGA/매니저            효과적인 SAGA 검색 수단(+매핑 인덱스) 필요           SAGA 타임아웃   특징     개별 애그리거트는 자신의 도메인 로직에만 집중하면 됨   한 비즈니스 프로세스와 관련된 흐름 제어가 한 곳에 모임            프로세스 변경 용이           (주로) 비동기 이벤트 기반   SAGA/프로세스 매니저 인스턴스 관리 위한 기반 프레임워크 필요  ","categories": ["Architecture"],
        "tags": ["DDD","도메인 주도 설계"],
        "url": "/architecture/ddd/",
        "teaser": null
      },{
        "title": "[HTTP] 인프런-HTTP 정리",
        "excerpt":"강의 내용 정리     인프런 : 모든 개발자를 위한 HTTP 웹 기본 지식 (김영한)   강의 출처   인터넷 네트워크   인터넷 통신   IP     Internet Protocol   흔히 말하는 IP는 IP 주소를 지칭   역할     지정한 IP 주소에 데이터를 전달   패킷이라는 통신 단위로 데이터 전달   서버 패킷 전달     네트워크 망이 복잡하기 때문에 송, 수신시 다른 망 경로(노드)로 전송될 수 있음     IP 프로토콜의 한계     비연결성(통신 대상이 서비스 불능)            패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷이 전송됨           비신뢰성(패킷 유실 또는 전달 순서 문제)            중간에 패킷이 사라지거나 순서대로 오지 않는 경우?           프로그램 구분            같은 IP 주소를 사용하는 서버에서 통신하는 앱이 2개 이상이라면?           이를 극복하기 위한 프로토콜이 TCP     TCP, UDP   IP 프로토콜 4계층     애플리케이션 계층 (HTTP, FTP)   전송 계층 (TCP, UDP)   인터넷 계층 (IP)   네트워크 인터페이스 계층     프로토콜 계층     애플리케이션            웹 브라우저       네트워크 게임       소켓 라이브러리           OS            TCP, UDP       IP           네트워크 인터페이스            LAN 드라이버, 장비           Ethernet frame (맥 주소 등 정보 포함)     패킷 정보     패킷은 패키지 + 버킷   IP 패킷            출발지 IP, 목적지 IP       기타           TCP/IP 패킷            출발지 PORT, 목적지 PORT       전송 제어, 순서, 검증 정보       기타             TCP 특징     전송 제어 프로토콜 (Transmission Control Protocol)   연결 지향            TCP 3 way handshake (가상 연결)                    논리적인 연결 (일종의 약속일 뿐)                       연결과정                    SYN (클라이언트에서 접속 요청)           SYN + ACK (서버에서 접속 요청 + 요청 수락)           ACK (클라이언트에서 요청 수락)                            최근에는 마지막 ACK 전송할 때 데이터도 함께 전송                                                   데이터 전달 보증            데이터를 올바르게 받은 경우 응답 전송           순서 보장            기본적으로 패킷 순서가 올바르지 않으면 재전송 요청 처리                    하지만 이는 네트워크 환경에 따라 다를 수 있음                           신뢰 가능한 프로토콜   현대 네트워크에서는 대부분 TCP 프로토콜이 사용됨     UDP 특징     사용자 데이터그램 프로토콜 (User Datagram Protocol)   TCP와 다르게 아래 기능들이 없기 때문에 흔히 백지에 비유            연결지향 (TCP 3 way handshake)       데이터 전달 보증       순서 보장           단순하기 때문에 빠름   IP 프로토콜과 거의 유사함 (PORT, 체크섬 정도만 추가됨)            따라서 애플리케이션에서 추가 작업이 필요함             PORT  통신시 사용되는 엔드포인트 (운영 체제 통신의 종단점)     하나의 클라이언트에서 여러 애플리케이션을 사용해 여러 곳을 동시에 연결해야 한다면?   같은 IP 주소 내에서 프로세스를 구분하기 위해 사용됨   PORT 할당     0 ~ 65535는 할당 가능   0 ~ 1023는 잘 알려진 포트, 가급적 사용하지 않는 것이 좋음            FTP (20, 21)       TELNET (23)       HTTP (80)       HTTPS (443)             DNS  IP 주소를 찾아주는 시스템(Domain Name System)     IP 주소는 숫자기 때문에 외우기 어려움   IP 주소는 변경될 가능성이 농후     URI, 웹 브라우저 요청 흐름   URI  Uniform Resource Identifier     Uniform            리소스를 식별하는 통일된 방식           Resource            자원, URI로 식별할 수 있는 모든 것 (제한 없음)           Identifier            다른 항목과 구분하는데 필요한 정보             URI, URL, URN 차이     URI            locator, name으로 (또는 둘다) 추가 분류될 수 있음       URI는 URL, URN을 포함           URL            Uniform Resource Locator       리소스 위치를 의미       문법                    scheme://[userinfo@]host[:port][/path][?query][#fragment]           https://www.google.com:443/search?q=hello&amp;hl=ko                            scheme(protocol) : https                                    (사전에 약속된) 자원에 접근하는 방식                                               userinfo                                    URL에 사용자 정보를 포함해 인증할 때 사용 (거의 사용되지 않음)                                               host : www.google.com               port : 443                                    http는 80, https 443 포트를 사용함 (이와 같이 사용하면 생략 가능)                                               path : /search                                    리소스 경로                   계층적 구조                                               query parameter : q=hello&amp;hl=ko                                    ?으로 시작하고 &amp;로 추가 가능                   쿼리 파라미터, 쿼리 스트링 등으로 지칭                   key=value 형태                                               fragment                                    HTML 내부 북마크 등에서 사용                   서버에 전송하는 정보가 아님                                                                                   URN            Uniform Resource Name       리소스명을 의미       URN만으로 실제 리소스를 찾는 방법은 보편화 되어 있지 않음             웹 브라우저 요청 흐름     DNS를 통해 IP 주소, 포트 정보를 획득   획득한 정보를 사용하여 HTTP 요청 메시지 생성     요청 데이터 포맷 예시 GET /serach?q=hello&amp;hl=ko HTTP/1.1 Host: www.google.com           웹 브라우저가 소켓 라이브러리를 통해 전달            TCP/IP 연결       데이터 전달       HTTP 메시지 포함하여 TCP/IP 패킷 생성           서버로 패킷 전송   서버는 수신한 패킷 처리   HTTP 응답 메시지 생성     응답 데이터 포맷 예시 HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Length: 3423     &lt;html&gt;     &lt;body&gt;...&lt;/body&gt; &lt;/html&gt;           서버도 마찬가지로 패킷 처리 후 반환   웹 브라우저는 수신한 데이터를 화면에 렌더링     HTTP  Hyper Text Transfer Protocol   HTTP 기본     초창기 하이퍼 텍스트 송수신을 위해 만들어졌으나 현재는 대부분에 통신을 HTTP로 함            HTML, TEXT       이미지, 음성, 영상, 파일 등       JSON, XML (API)       그 외 거의 모든 형태의 데이터 전송 가능       서버 간 데이터 통신             버전별 특징     0.9 (1991)            GET 메서드만 지원, HTTP 헤더 없음           1.0 (1996)            HTTP 메서드 및 헤더 추가           1.1 (1997)            현재 가장 많이 사용되는 버전       RFC2068(1997) &gt; RFC2616(1999) &gt; RFC7230 ~ 7235(2014)           2 (2015)            SPDY 기반       성능 개선       HTTP 헤더 데이터 압축       서버 푸시 기능       요청을 HTTP 파이프라인으로 처리       하나의 TCP 연결로 여러 요청 처리 가능           3 (개발 진행중)            TCP 대신 UDP를 사용하여 성능 개선       QUIC 기반             기반 프로토콜     HTTP 1.1, 2 버전은 TCP 기반   HTTP 3 버전은 UDP 기반     특징     클라이언트-서버 구조            요청-응답 구조       클라이언트가 서버에 요청을 보내고 서버의 응답을 대기       서버가 요청에 대한 결과를 만들어 응답           Stateless (무상태성)            서버가 클라이언트의 상태 정보를 보존하지 않음 (반대는 Stateful)                    간혹 모든 것을 무상태로 설계할 수 없는 경우도 존재           로그인 등은 상태 유지가 필요                            일반적으로 쿠키, 세션 등을 사용해 상태 유지                                   상태 유지는 가급적 최소화                       장점                    서버의 확장성이 높음 (스케일 아웃 환경)                       단점                    클라이언트의 추가 데이터 전송 필요                           Connectionless (비연결성)            클라이언트와 계속 연결된 상태라면 서버의 리소스가 많이 소모됨       HTTP는 기본적으로 비연결 모델       일반적으로 초 단위 이하의 빠른 속도로 응답       장점                    서버 리소스를 효율적으로 사용 가능                       단점                    매 통신마다 새로운 TCP(3 way handshake) 연결이 필요해 비효율적           수많은 리소스(HTML, JS, CSS 등) 다운로드가 필요하기 때문                            HTTP Persistent Connections(지속 연결)로 해당 문제 해결               HTTP 2, 3 버전에서 더 많은 최적화                                                     HTTP 메시지     HTTP 메시지 구조     start-line   : 시작 라인 header       : 헤더 empty line   : 공백 라인 (CRLF) message body : 메시지 바디           공식 스펙     MTTP-message = start-line                * ( header-field CRLF )                CRLF                [ message-body ]           요청 메시지            요청 메시지도 body 본문을 가질 수 있음           응답 메시지            요청 메시지랑 시작 라인이 다름           단순, 확장 가능            HTTP 스펙과 메시지는 단순함       크게 성공하는 표준 기술은 단순하면서도 확장 가능함             HTTP 요청 메시지 시작 라인     start-line = (request-line / status-line)   request-line = method SP(공백) request-target SP HTTP-version CRLF(엔터)     GET /serach?q=hello&amp;hl=ko HTTP/1.1                 HTTP 메서드 (GET: 조회)                    서버가 수행할 동작 지정           GET, POST, PUT, DELETE, 기타                       요청 대상 (/serach?q=hello&amp;hl=ko)                    absolute-path[?query] 절대경로[?쿼리]           절대 경로 = /로 시작하는 경로           http://..?x=y와 같이 다른 유형의 경로 지정 방법도 존재                       HTTP Version             HTTP 응답 메시지 시작 라인     start-line = (request-line / status-line)   status-line = HTTP-version SP status-code SP reason-phrase CRLF     HTTP/1.1 200 OK                 HTTP 버전       HTTP 상태 코드 (요청, 성공 등과 같은 정보 표현)                    200 (성공)           400 (클라이언트 요청 오류)           500 (서버 내부 오류)                       reason-phrase (짧은 상태 코드 설명)             HTTP 헤더     header-field = field-name : OWS field-value OWS (OWS: 띄어쓰기 허용)   field-name은 대소문자 구문 없음            값은 대소문자 구분           HTTP 전송에 필요한 모든 부가 정보            메시지 바디 내용 및 크기       압축       인증       요청 클라이언트(브라우저) 정보       서버 앱 정보       캐시 관리 정보       기타           표준 헤더가 너무 많음   필요에 따라 임의의 헤더 추가 가능     HTTP 메시지 바디   실제 전송 데이터     HTML, 이미지, 영상, 기타 JSON 데이터 등 byte로 표현 가능한 모든 데이터     HTTP 메서드     HTTP API 설계            리소스의 의미?                    행위 자체가 리소스가 아님                       회원 조회, 등록 기능에서 회원이라는 개념 자체가 리소스                    회원이라는 리소스만 식별 &gt; 회원 리소스를 URI에 매핑                       리소스와 행위를 분리                    행위를 HTTP 메서드로 표현                           종류            GET                    리소스 조회                       POST                    리소스 생성 및 등록, 요청 데이터 처리                       PUT                    리소스를 대체, 없다면 생성           디렉토리에 파일을 넣는 것과 비슷                       PATCH                    리소스의 부분을 변경 (회원 정보 변경 등)                       DELETE                    리소스 삭제                       HEAD                    GET과 동일하지만 메시지 부분 제외하고 상태와 헤더만 반환                       OPTIONS                    대상 리소스에 대한 통신 가능한 옵선(메서드)을 설명 (주로 CORS에서 사용됨)                       CONNECT                    대상 리소스로 식별되는 서버에 대한 터널을 설정함                       TRACE                    대상 리소스에 대한 경로를 따라 메시지 루프백 테스트 수행                           최근에는 Resource를 Representation으로 표현하여 사용     GET     리소스 조회   쿼리 스트링을 통해 데이터 전달   스펙상 메시지 바디를 이용해 데이터 전달 가능            하지만 지원하지 않는 곳이 많아 실무에서는 권장되지 않음           요청     GET /members/100 HTTP/1.1 Host: localhost:8080           응답     HTTP/1.1 200 OK Content-Type: application/json Content-Length: 34    {     \"username\": \"young\",     \"age\": 20 }             POST     요청 데이터 처리   POST 요청 스펙            대상 리소스가 요청에 포함된 표현을 리소스의 고유한 의미 체계에 따라 처리하도록 요청           메시지 바디를 통해 서버로 요청 데이터 전달            서버는 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능 수행           주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용됨            HTML 양식에 입력된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공                    HTML FORM에 입력된 정보로 회원 가입, 주문 등 처리                       게시판, 뉴스 그룹, 메일링 리스트, 블로그 등 유사한 기사 그룹에 메시지 게시                    게시판, 댓글 작성                       서버가 식별하지 않은 새 리소스 생성                    신규 주문 생성                       기존 리소스에 데이터 추가                    문서에 내용 추가                           리소스 URI에 POST 요청이 오면 데이터를 어떻게 처리할 지 리소스마다 개별적인 설정 필요   정리            새 리소스 생성 및 등록       요청 데이터 처리                    단순한 데이터 변경이 아니고 프로세스를 처리해야 하는 경우                            주문 &gt; 결제 완료 &gt; 배달 시작 &gt; 배달 완료처럼 프로세스의 상태가 변경되는 경우               이때 새로운 리소스가 생성되지 않을 수 있음                                   POST /orders/{orderId}/start-delivery (컨트롤 URI)                       다른 메서드로 처리하기 어렵거나 애매한 경우                    조회 시 조회 데이터(JSON 등)로 인해서 GET 메서드를 사용하기 어려운 경우                           요청     POST /members HTTP/1.1 Content-Type: application/json    {     \"username\": \"hello\",     \"age\": 20 }           응답     HTTP/1.1 201 Created Content-Type: application/json Content-Length: 34 Location: /members/100    {     \"username\": \"young\",     \"age\": 20 }             PUT     해당 리소스를 대체            리소스가 없으면 생성, 있으면 대체 (덮어 쓰기)           클라이언트가 리소스를 식별 (POST와 차이점)            클라이언트가 리소스 위치(경로)를 알고 URI 지정       만약 특정 필드가 없는 경우 해당 필드 삭제 처리             PATCH     해당 리소스의 부분 변경   만약 특정 필드가 없는 경우에도 해당 필드 보존   간혹 PATCH를 사용하지 못하는 경우 POST를 대신 사용     DELETE     해당 리소스 제거     HTTP 메서드 속성     안전 (Safe Methods)            GET, HEAD 등은 호출해도 리소스를 변경하지 않음       그 외 다른 부분은 안전하지 않음 (해당 리소스만)           멱등 (Idempotent Methods)            외부의 개입이 없다면 몇번을 호출하든지 결과가 동일함                    GET           PUT           DELETE                       POST는 멱등이 아님       멱등의 활용                    자동 복구 메커니즘           서버가 TIMEOUT 등 정상 응답을 주지 못한 경우, 같은 요청 재시도 가능 여부 판단 시 활용                           캐시 가능 (Cacheable Methods)            GET, HEAD, POST, PATCH 캐시 가능 (실제로는 GET, HEAD 정도만 캐싱)                    GET, HEAD 등은 URI만으로만 캐싱 키를 설정           POST, PATCH는 본문 내용까지 캐싱 키로 설정해야 하기 때문에 구현이 어려움                             HTTP 메서드 활용     쿼리 스트링을 통한 데이터 전송            GET       정렬 필터 (검색어)           메시지 바디를 통한 데이터 전송            POST, PUT, PATCH       회원 가입, 상품 주문 등 리소스 등록과 변경             클라이언트에서 서버로 데이터 전송     정적 데이터 조회            이미지, 정적 텍스트 문서 등       조회는 GET 사용       일반적으로 쿼리 스트링 없이 리소스 경로만으로 단순 조회 가능           동적 데이터 조회            검색, 게시판 목록 내 정렬 필터 (검색어)       필터링, 정렬 조건 등에 주로 사용       조회는 GET 사용 (쿼리 스트링)                    실무에서 GET 요청 시 메시지 바디 사용을 권장하지 않음                           HTML Form을 통한 데이터 전송            회원 가입, 상품 주문 등 데이터 변경       Content-Type: application/x-www-form-urlencoded                    Form 내용을 메시지 바디에 담아 전송 (key, value 형태)           전송 데이터를 url 인코딩 처리                       Content-Type: multipart/form-data;                    파일 업로드 같은 바이너티 데이터 전송시 사용됨           다른 종류의 여러 파일, Form 내용도 함께 전송 가능                       HTML Form 전송은 GET, POST만 지원           HTTP API를 통한 데이터 전송            회원 가입, 상품 주문 등 데이터 변경       서버 &lt;-&gt; 서버       앱                    아이폰, 안드로이드                       웹 클라이언트 (Ajax)                    HTML에서 Form 형태 전송 대신 JS AJAX 통신 사용                       POST, PUT, PATCH                    메시지 바디를 통해 데이터 전송                       GET                    쿼리 스트링으로 데이터 전달                       Content-Type: application/json;을 주로 사용 (표준에 가까움)                    TEXT, XML, JSON 등을 사용할 수 있음                             HTTP 설계 예시     HTTP API - 컬렉션            POST 등록 (회원 관리 API 제공)           HTTP API - 스토어            PUT 등록 (정적 컨텐츠, 원격 파일 등 관리)           HTML Form 사용            GET, POST만 지원 (웹 페이지 회원 관리)             회원 관리 시스템 (POST 기반)     회원 목록 /members -&gt; GET   회원 등록 /members -&gt; POST   회원 조회 /members/{id} -&gt; GET   회원 수정 /members/{id} -&gt; PATCH, PUT, POST   회원 삭제 /members/{id} -&gt; DELETE   특징            클라이언트는 등록될 리소스의 URI를 모름                    회원 등록 /members -&gt; POST           POST /members                       서버가 새로 등록된 리소스 URI를 생성해 반환         HTTP/1.1 201 Created      Location: /members/100                       컬렉션(Collection)                    서버가 관리하는 리소스 디렉토리           서버가 리소스의 URI를 생성하고 관리           여기서 컬렉션은 /members                             파일 관리 시스템 (PUT 기반)     파일 목록 /files -&gt; GET   파일 조회 /files/{filename} -&gt; GET   파일 등록 /files/{filename} -&gt; PUT   파일 삭제 /files/{filename} -&gt; DELETE   파일 대량 등록 /files -&gt; POST   특징            클라이언트가 리소스 URI를 알고 있어야 함                    파일 등록 /files/{filename} -&gt; PUT           PUT /files/star.jpg                       클라이언트가 직접 리소스의 URI를 지정       스토어(Store)                    클라이언트가 관리하는 리소스 저장소           클라이언트가 리소스의 URI를 알고 관리           여기서 스토어는 /files                             회원 관리 시스템(HTML Form 사용)     회원 목록 /members -&gt; GET   회원 등록 폼 /members/new -&gt; GET   회원 등록 /members/new, /members -&gt; POST            POST 요청과 GET 요청의 URI를 맞추는 것도 고려                    예를 들어 유효성 검사 중 문제가 발생한 경우  POST 요청의 최종 데이터를 담아 회원 등록 Form으로 다시 보내야 할 때  경로가 다르면 리프레시 등으로 원래 Form으로 돌아가기 어려움                           회원 조회 /members/{id} -&gt; GET   회원 수정 폼 /members/{id}/edit -&gt; GET   회원 수정 /members/{id}/edit, /members/{id} -&gt; POST   회원 삭제 /members/{id}/delete -&gt; POST   특징            순수 HTML Form은 GET, POST만 지원 (제한적)       컨트롤 URI (동사 사용)                    GET, POST만 사용할 수 밖에 없는 제약 극복을 위해 사용           POST 요청과 /new, /edit, /delete 등의 컨트롤 URI를 함께 사용하여 처리           추가적으로 HTTP 메서드로 해결하기 애매한 경우 사용                       AJAX 등 기술을 통해 해결             참고하면 좋은 URI 설계 개념     문서 (document)            단일 개념(파일 하나, 객체 인스턴스, 데이터베이스 row)       예) /members/100, /files/star.jpg           컬렉션 (collection)            서버가 관리하는 리소스 디렉터리       서버가 리소스의 URI를 생성하고 관리       예) /members           스토어 (store)            클라이언트가 관리하는 자원 저장소       클라이언트가 리소스의 URI를 알고 관리       예) /files           컨트롤러 (controller), 컨트롤 URI            문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행       동사를 직접 사용       예) /members/{id}/delete           참고 문서     HTTP 상태코드  클라이언트가 보낸 요청의 처리 상태를 응답(반환) 시 표현하는 기능     클라이언트가 인식할 수 없는 상태 코드를 서버가 반환하는 경우   상위 상태코드로 해석하여 처리   따라서 새로운 상태코드라도 클라이언트를 변경하지 않아도 됨   예시            299 ??? -&gt; 2xx (Successful)       451 ??? -&gt; 4xx (Client Error)       599 ??? -&gt; 5xx (Server Error)             1xx   요청이 수신되어 처리중 (Informational)     거의 사용되지 않음     2xx   요청 정상 처리 (Successful)     200 (OK)            요청 처리 완료           201 (Created)            요청 성공으로 새로운 리소스 생성 완료           202 (Accepted)            요청 접수는 완료, 처리는 완료되지 않음 (배치 처리 등)           204 (No Content)            요청 처리 완료, 응답 페이로드 본문에 반환할 데이터가 없음 (문서 저장 기능 등)             3xx   요청을 완료하려면 유저 에이전트의 추가 조치 필요 (Redirection)      300 (Multiple Choices)            거의 사용되지 않음           301 (Moved Permanently)            영구적인 리다이렉션       리다이렉트 시 요청 메서드가 GET으로 변경됨, 본문이 제거될 수 있음           302 (Found)            일시적인 리다이렉션       리다이렉트 시 요청 메서드가 GET으로 변경됨, 본문이 제거될 수 있음           303 (See Other)            일시적인 리다이렉션       302와 기능은 같음       리다이렉트 시 요청 메서드가 GET으로 (반드시) 변경됨           304 (Not Modified)            캐싱 목적으로 사용       리소스가 변경되지 않음을 명시, 클라이언트는 로컬 캐시 데이터를 재사용       응답 시 메시지 바디를 포함하면 안됨       조건부 GET, HEAD 요청 시 사용           307 (Temporary Redirect)            일시적인 리다이렉션       302와 기능은 같음       리다이렉트 시 요청 메서드와 본문 유지 (요청 메서드를 절대 변경하면 안됨)           308 (Permanent Redirect)            영구적인 리다이렉션       301과 기능은 같음       리다이렉트 시 요청 메서드와 본문 유지                    처음 요청이 POST면 리다이렉트 시에도 POST 유지                       일반적으로 URL이 변경되면 처리할 데이터 포맷도 바뀌는 경우가 대부분  따라서 308보다는 301로 처리하는 경우가 많음           URL 리다이렉션 또는 리다이렉트     URL 넘겨주기   웹 브라우저는 3xx 응답을 받을 때 Location 헤더가 존재하면 Location 위치로 자동 이동   종류            영구적인 리다이렉션 (특정 리소스의 URI가 영구적으로 이동됨)                    원래의 URL이 사용되지 않음을 표현, 검색 엔진 등에서도 변경 인지           예) /members -&gt; /users           예) /events -&gt; /new-event           301, 308 등                       일시적인 리다이렉션 (일시적으로 변경)                    일시적인 변경이기 때문에 검색 엔진 등에서 URL을 변경하면 안됨           주문 완료 후 주문 내역 화면으로 이동           PRG : Post/Redirect/Get           302, 303, 307 등                       특수한 리다이렉션                    결과 대신 캐시 사용                           PRG (Post/Redirect/Get)     POST 주문 후에 새로고침으로 인한 중복 주문 방지   주문 후 결과 화면을 GET 메서드로 리다이렉트   이후부터 새로고침을 해도 결과 화면을 GET으로 조회   중복 주문 대신 결과 화면만 GET으로 다시 요청   예시            POST 요청에 대한 응답으로 302 코드와 URL을 반환하여 자동 리다이렉트       이후부터 결과 화면에서 새로고침을 하더라도 GET 요청을 하게 됨           정리     일시적인 리다이렉트 시 302, 303, 307 중 어떤 것을 사용해야 하는가?            302 (Found)                    GET으로 변할 수 있음 (가능성)                       303 (See Other)                    GET으로 변경 (확실)                       307 (Temporary Redirect)                    메서드가 변경되면 안됨                           History            처음 302 설계 의도는 HTTP 메서드를 유지하는 것       하지만 웹 브라우저들이 대부분 GET 메서드로 변경 (일부 예외 존재)       302 스펙이 모호해져 303, 307이 등장 (301을 위해 308 등장)           실무            303, 307 등을 권장하지만 이미 302를 대부분 기본값으로 사용하는 상황       자동 리다이렉션 시 GET 메서드로 변경해도 괜찮다면 그냥 302 사용 가능             4xx   클라이언트 오류, 잘못된 문법 등으로 서버의 요청 처리 실패 (Client Error)          오류의 원인이 클라이언트에게 있는 경우     이미 잘못된 요청이기 때문에 똑같은 재시도 또한 실패함         400 (Bad Request)            클라이언트의 잘못된 요청으로 처리할 수 없음       클라이언트는 요청 검토 후 다시 요청해야 함 (요청 구문, 메시지 등 오류)       예) 잘못된 요청 파라미터를 전송하는 경우, API 스펙이 맞지 않는 경우           401 (Unauthorized)            해당 리소스 요청에 대한 인증이 필요함       해당 상태코드 반환 시 WWW-Authenticate 헤더를 통해 인증 방법을 함께 반환       이름(인가되지 않음)과 다르게 인증의 문제       참고                    인증(Authentication)                            본인이 누구인지 확인 (로그인)                                   인가(Authorization)                            권한부여 (어드민 권한처럼 특정 리소스에 접근할 수 있는 권한, 인증 후 절차)                                                   403 (Forbidden)            서버의 승인 거부       일반적으로 인가 권한이 부족한 경우에 사용       예) 일반 사용자가 어드민 권한이 필요한 리소스에 접근하는 경우           404 (Not Found)            요청 리소스를 찾을 수 없음       클라이언트가 권한이 부족한 리소스에 접근 시도 시 해당 리소스를 숨기고 싶은 경우             5xx   서버 오류, 서버의 정상 요청 처리 실패 (Server Error)          오류의 원인이 서버에게 있는 경우     서버 처리 문제기 때문에 똑같은 재시도 시 결과가 달라질 수 있음         500 (Internal Server Error)            서버 내부 문제로 발생한 오류       그 외 서버에서 애매한 오류가 발생한 경우           503 (Service Unavailable)            서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없음       Retry-After 헤더 필드로 얼마뒤에 복구되는지 보낼 수도 있음             HTTP 헤더   헤더 필드     field-name : OWS field-value OWS (OWS : 띄어쓰기 허용)   field-name은 대소문자 구문 없음   용도     HTTP 전송에 필요한 모든 부가정보            예시                    메시지 바디의 내용, 크기, 압축, 인증           요청 클라이언트           서버 정보                           표준 헤더가 너무 많음   임의의 헤더 추가 가능     헤더 분류     General 헤더            메시지 전체에 적용되는 정보 (요청, 응답과 무관한 헤더)       예) Connection: close           Request 헤더            요청 정보       예) User-Agent: Mozilla/5.0 (Macintosh; ..)           Response 헤더            응답 정보       예) Server: Apache           Entity 헤더            엔티티 바디 정보       예) Content-Type: text/html, Content-Length: 3423             메시지 바디   개정 전     메시지 본문은 엔티티 본문을 전달하는데 사용   엔티티는 요청이나 응답 시 전달할 실제 데이터   엔티티 헤더            엔티티 본문의 데이터를 해석할 수 있는 정보 제공       데이터 유형, 길이, 압축 정보 등           개정     RFC2616 폐기 -&gt; RFC7230~7235   엔티티(Entity) -&gt; 표현(Representation)   Representation (표현 = 표현 메타데이터 + 표현 데이터)            Representation Meta data + Representation Data           현재     메시지 본문을 통해 표현 데이터 전달            메시지 본문은 페이로드(payload)           표현은 요청, 응답 시 전달할 실제 데이터   표현 헤더            표현의 데이터를 해석할 수 있는 정보 제공       데이터 유형, 길이, 압축 정보 등       표현 메타데이터와 페이로드 메시지를 구분             표현  표현 헤더는 전송, 응답 둘다 사용     Content-Type            표현 데이터의 형식 (미디어 타입, 문자 인코딩)       예시                    text/html; charset=utf-8           application/json (기본이 UTF-8)           image/png                           Content-Encoding            표현 데이터의 압축 방식                    데이터를 보내는 측에서 압축 후 인코딩 헤더 추가           데이터를 받는 쪽에서 인코딩 헤더 정보로 압축 해제                       예시                    gzip           deflate           identity (압축 안함)                           Content-Language            표현 데이터의 자연 언어       예시                    ko           en           en-US                           Content-Length            표현 데이터의 길이 (바이트 단위)       명확하게 페이로드 헤더       Transfer-Encoding(전송 코딩) 사용 시 Content-Length 사용하면 안됨                    Transfer-Encoding 안에 정보가 이미 있음                             협상   클라이언트가 선호하는 표현 요청 (요청 시에만 사용)     Accept            클라이언트가 선호하는 미디어 타입 전달           Accept-Charset            클라이언트가 선호하는 문자 인코딩           Accept-Encoding            클라이언트가 선호하는 압축 인코딩           Accept-Language            클라이언트가 선호하는 자연 언어             협상 우선순위 1     Quality Values(q) 사용   0~1, 클수록 높은 우선순위 (생략하면 1)   Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7            ko-KR;q=1 (q생략)       ko;q=0.9       en-US;q=0.8       en:q=0.7           협상 우선순위 2     구체적인 것이 우선 순위가 높음   Accept: text/*, text/plain, text/plain;format=flowed, */*            text/plain;format=flowed       text/plain       text/*       /           협상 우선순위 3     구체적인 것을 기준으로 미디어 타입을 맞춤   Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1, text/html;level=2;q=0.4, */*;q=0.5                                   Media Type           Quality                                           text/html;level=1           1                             text/html           0.7                             text/plain           0.3                             image/jpeg           0.5                             text/html;level=2           0.4                             text/html;level=3           0.7                             전송 방식     Transfer-Encoding   Range, Content-Range   상세     단순 전송            일반 전송         HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Length: 3423      &lt;html&gt;     &lt;body&gt;...&lt;/body&gt; &lt;/html&gt;                           압축 전송            Content-Encoding 사용         HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Encoding: gzip Content-Length: 521  lkj123kljoiasudlkjaweioluywlnfdo912u34ljko98udjkl                           분할 전송            Transfer-Encoding 사용         HTTP/1.1 200 OK Content-Type: text/plain Transfer-Encoding: chunked  5 Hello 5 World 0 \\r\\n                       Content-Length 삽입하지 말 것                    분할 시 예상하기 어려움           분할된 파트마다 길이를 별도로 표현                           범위 전송            Range 사용 (특정 범위를 지정해서 전송 요청)         GET /event Range: bytes=1001-2000                       Content-Range 사용 (요청 범위 반환)         HTTP/1.1 200 OK Content-Type: text/plain Content-Range: bytes 1001-2000 / 2000      qweqwe1l2iu3019u2oehj1987askjh3q98y                             일반 정보     From            유저 에이전트의 이메일 정보       일반적으로 자주 사용되지 않음       검색 엔진 등에서 주로 사용       요청 시 사용           Referer            이전 웹 페이지 주소       유입 경로 분석 가능       referrer 오타       요청 시 사용           User-Agent            유저 에이전트 애플리케이션 정보 (웹 브라우저 등)       어떤 환경(브라우저)에서 장애가 발생하는지 분석 가능       요청 시 사용           Server            요청을 처리하는 오리진 서버의 소프트웨어 정보       Server: Apache/2.2.22 (Debian)       Server: nginx       응답 시 사용           Date            메시지가 생성된 날짜       Date: Tue, 15 Nov 1994 08:12:31 GMT       응답 시 사용             특별 정보     Host            요청한 호스트 정보(도메인)       요청 시 사용       필수 정보       하나의 서버가 여러 도메인을 처리해야 하는 경우       하나의 IP 주소에 여러 도메인이 적용되어 있는 경우           Location            페이지 리다이렉션       201 (Created)       3xx (Redirection)           Allow            허용 가능한 HTTP 메서드       405 (Method Not Allowed) 반환 시 응답에 포함해야 함                    예) Allow: GET, HEAD, PUT                       일반적으로 실무에서 잘 사용되지 않음           Retry-After            유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간       503 (Service Unavailable) 반환 시 언제까지 장애 상태인지 알려줄 수 있음                    예) Retry-After: Fri, 31 Dec 1999 23:59:59 GMT (날짜 표기)           예) Retry-After: 120 (초단위 표기)                       일반적으로 실무에서 사용하기 어려움             인증     Authorization            클라이언트 인증 정보를 서버에 전달       Authorization: Basic xxxxxxxxxxxxxxxx           WWW-Authenticate            리소스 접근시 필요한 인증 방법 정의       401 (Unauthorized) 응답과 함께 사용                    예) WWW-Authenticate: Newauth realm=\"apps\", type=1, title=\"Login to \\\"apps\\\"\", Basic realm=\"simple\"                             쿠키     Set-Cookie            서버에서 클라이언트로 쿠키 전달(응답)           Cookie            클라이언트가 서버에서 받은 쿠키를 저장, HTTP 요청시 서버로 전달           Stateless - 쿠키 사용 이유     요청에 대한 응답 후 연결은 끊어짐   연결이 끊어지면 이전 요청을 기억하지 못함   매 요청마다 정보를 넘기는 것은 문제            모든 요청에 사용자 정보가 포함되도록 개발해야 함       브라우저를 완전 종료 후 다시 실행하면?                    이때 웹 스토리지 사용 가능                             쿠키 사용 예시     set-cookie: sessionId=abcde1234; expires=Sat, 26-Dec-2020 00:00:00 GMT; path=/; domain=.google.com; Secure   사용처            사용자 로그인 세션 관리       광고 정보 트래킹           쿠키 정보는 항상 서버에 전송됨            네트워크 트래픽 추가 유발       최소한의 정보만 사용(세션 id, 인증 토큰)       서버에 전송하지 않고, 웹 브라우저 내부에 데이터를 저장 시 웹 스토리지 사용                    localStorage, sessionStorage 등 참고                           주의점            쿠키, 웹 스토리 상관 없이 보안에 민감한 데이터는 저장하면 안됨                    주민번호, 신용카드 번호 정보 등                             쿠키 생명주기     Set-Cookie: expires=Sat, 26-Dec-2020 04:39:21 GMT            일반적으로 GMT 표기       만료일이 되면 쿠키 삭제           Set-Cookie: max-age=3600 (3600초)            0이나 음수를 지정하면 쿠키 삭제           세션 쿠키            만료 날짜를 생략하면 브라우저 종료할 때까지만 유지           영속 쿠키            만료 날짜를 입력하면 해당 날짜까지 유지             쿠키 접근 도메인     예) domain=example.org   명시 (명시한 문서 기준 도메인 + 서브 도메인 포함)            domain=example.org를 지정해서 쿠키 생성                    example.org 쿠키 접근           dev.example.org도 쿠키 접근                           생략 (현재 문서 기준 도메인만 적용)            example.org에서 쿠키를 생성하고 domain 지정을 생략                    example.org 에서만 쿠키 접근           dev.example.org는 쿠키 미접근                             쿠키 접근 경로     예) path=/home   이 경로를 포함한 하위 경로 페이지만 쿠키 접근   일반적으로 path=/ 루트로 지정   예)            path=/home 지정       /home -&gt; 가능       /home/level1 -&gt; 가능       /home/level1/level2 -&gt; 가능       /hello -&gt; 불가능             쿠키 접근 보안     Secure            기본적으로 쿠키는 http, https를 구분하지 않고 전송       Secure를 적용하면 https인 경우에만 전송           HttpOnly            XSS 공격 방지       자바스크립트에서 접근 불가(document.cookie)       HTTP 전송에만 사용           SameSite            XSRF(CSRF( 공격 방지       요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송       브라우저의 지원 정도를 확인 후 사용할 것             캐시     캐시 미적용     HTTP/1.1 200 OK Content-Type: image/jpeg Content-Length: 34012  lkj123kljoiasudlkjaweioluywlnfdo912u34ljko98udjkla slkjdfl;qkawj9;o4ruawsldkal;skdjfa;ow9ejkl3123123                 데이터 변경이 없어도 네트워크를 통해 계속 데이터를 다운로드 함       네트워크는 매우 느리고 비쌈       브라우저 로딩 속도가 느림       느린 사용자 경험           캐시 적용     HTTP/1.1 200 OK Content-Type: image/jpeg cache-control: max-age=60 Content-Length: 34012    lkj123kljoiasudlkjaweioluywlnfdo912u34ljko98udjkla slkjdfl;qkawj9;o4ruawsldkal;skdjfa;ow9ejkl3123123                 요청 전 캐싱 유효 시간 확인하여 캐시 사용                    유효 시간 초과한 경우만 다시 요청, 캐시 갱신                       브라우저 로딩 속도가 빠름       빠른 사용자 경험             캐시 시간 초과     캐시가 만료된 후에 데이터 갱신 여부에 따라 캐싱된 데이터 재사용 가능            검증 헤더를 사용하여 데이터(기존-서버)간 갱신 유무를 비교           Last-Modified 적용 후 캐시 시나리오     검증 헤더 추가     HTTP/1.1 200 OK Content-Type: image/jpeg cache-control: max-age=60 Last-Modified: 2020년 11월 10일 10:00:00 Content-Length: 34012    lkj123kljoiasudlkjaweioluywlnfdo912u34ljko98udjklasl kjdfl;qkawj9;o4ruawsldkal;skdjfa;ow9ejkl3123123           캐시가 만료된 후 다시 요청 (조건부 요청)     GET /star.jpg if-modified-since: 2020년 11월 10일 10:00:00           갱신된 것이 없을 때 304 (Not Modified) 반환            메시지 바디가 없음 (갱신된 것이 없기 때문에)         HTTP/1.1 304 Not Modified Content-Type: image/jpeg cache-control: max-age=60 Last-Modified: 2020년 11월 10일 10:00:00 Content-Length: 34012                           정리     캐시 유효 시간을 초과해도 갱신된 것이 없다면 304 반환            304 (Not Modified) + 헤더 메타 정보만 응답 (바디X)       클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신       클라이언트는 캐시에 저장되어 있는 데이터 재활용       결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드           매우 실용적     검증 헤더와 조건부 요청     검증 헤더            캐시 데이터와 서버 데이터를 비교하여 같은지 검증       Last-Modified       ETag (Last-Modified 태그의 단점 보완)           조건부 요청 헤더            검증 헤더로 조건에 따른 분기       If-Modified-Since: Last-Modified 사용       If-None-Match: ETag 사용       조건이 만족하면 200 (OK)       조건이 만족하지 않으면 304 (Not Modified)             Last-Modified, If-Modified-Since     데이터 미변경 예시            캐시: 2020년 11월 10일 10:00:00 vs 서버: 2020년 11월 10일 10:00:00       304 (Not Modified), 헤더 데이터만 전송 (바디 미포함)       전송 용량 0.1M (헤더 0.1M, 바디 1.0M)           데이터 변경 예시            캐시: 2020년 11월 10일 10:00:00 vs 서버: 2020년 11월 10일 11:00:00       200 (OK), 모든 데이터 전송(BODY 포함)       전송 용량 1.1M (헤더 0.1M, 바디 1.0M)           단점            1초 미만(0.x초) 단위로 캐시 조정이 불가능       날짜 기반의 로직 사용       데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우       서버에서 별도의 캐시 로직을 관리하고 싶은 경우       예) 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우             ETag, If-None-Match     ETag(Entity Tag)   캐시용 데이터에 임의의 고유한 버전 이름을 태깅            예) ETag: “v1.0”, ETag: “a2jiodwjekjl3”           데이터가 변경되면 이 이름을 바꾸어서 변경함 (Hash를 다시 생성)            예) ETag: “aaaaa” -&gt; ETag: “bbbbb”           진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 다운로드   ETag 적용 후 캐시 시나리오     조건부 검증 헤더 추가     HTTP/1.1 200 OK Content-Type: image/jpeg cache-control: max-age=60 ETag: \"aaaaaaaaaa\" Content-Length: 34012    lkj123kljoiasudlkjaweioluywlnfdo912u34ljko98udjklasl kjdfl;qkawj9;o4ruawsldkal;skdjfa;ow9ejkl3123123           캐시가 만료된 후 다시 요청 (조건부 요청)     GET /star.jpg If-None-Match: \"aaaaaaaaaa\"           갱신된 것이 없을 때 304 (Not Modified) 반환            메시지 바디가 없음 (갱신된 것이 없기 때문에)         HTTP/1.1 304 Not Modified Content-Type: image/jpeg cache-control: max-age=60 ETag \"aaaaaaaaaa\" Content-Length: 34012                           정리     캐시 제어 로직을 서버에서 완전히 관리   클라이언트는 단순히 이 값을 서버에 제공 (클라이언트는 캐시 메커니즘을 모름)   예시            서버는 배타 오픈 기간인 3일 동안 파일이 변경되어도 ETag를 동일하게 유지       애플리케이션 배포 주기에 맞추어 ETag 모두 갱신             캐시 제어 헤더     Cache-Control (캐시 지시어, 캐시 제어)            Cache-Control: max-age                    캐시 유효 시간, 초 단위           일반적으로 긴 시간으로 설정                       Cache-Control: no-cache                    데이터는 캐시해도 되지만, 항상 조건부 요청을 통해 origin 서버에 검증 받은 후 사용           캐시 서버 무시                       Cache-Control: no-store                    데이터에 민감한 정보가 있으므로 저장하면 안됨 (메모리에서 사용하고 최대한 빨리 삭제)                           Pragma (캐시 제어 - 하위 호환)            Pragma: no-cache       HTTP 1.0 하위 호환           Expires (캐시 유효 기간 - 하위 호환)            캐시 만료일 지정 하위 호환 (정확한 날짜로 지정)       HTTP 1.0 부터 사용       지금은 더 유연한 Cache-Control: max-age 권장       Cache-Control: max-age와 함께 사용하면 Expires는 무시           검증 헤더, 조건부 요청 헤더 정리     검증 헤더            ETag: “v1.0”, ETag: “asid93jkrh2l”       Last-Modified: Thu, 04 Jun 2020 07:19:24 GMT           조건부 요청 헤더            If-Match, If-None-Match                    ETag 값 사용                       If-Modified-Since, If-Unmodified-Since                    Last-Modified 값 사용                             프록시 캐시   Cache-Control     Cache-Control: public            응답이 public 캐시에 저장되어도 됨           Cache-Control: private (기본값)            응답이 해당 사용자만을 위한 것임, private 캐시에 저장해야 함           Cache-Control: s-maxage            프록시 캐시에만 적용되는 max-age           Age: 60 (HTTP 헤더)            오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간(초)           캐시 무효화     브라우저가 임의로 캐시 처리를 할 수 있기 때문에 해당 설정을 모두 적용하여 캐시 무효화   확실한 캐시 무효화 응답   Cache-Control: no-cache, no-store, must-revalidate            Cache-Control: no-cache                    데이터는 캐시해도 되지만, 항상 조건부 요청을 통해 origin 서버에 검증 받은 후 사용                       Cache-Control: no-store                    데이터에 민감한 정보가 있으므로 저장하면 안됨 (메모리에서 사용하고 최대한 빨리 삭제)                       Cache-Control: must-revalidate                    캐시 만료 후 최초 조회 시 origin 서버에 검증해야 함           origin 서버 접근 실패 시 반드시 오류가 발생해야 함 - 504(Gateway Timeout)           must-revalidate는 캐시 유효 시간이라면 캐시 사용                           Pragma: no-cache            HTTP 1.0 하위 호환을 위해 적용           no-cache, must-revalidate 비교   장애 발생으로 origin 서버 접근 불가능한 경우     no-cache는 캐시 서버 설정에 따라 오래된 데이터라도 반환 가능   must-revalidate는 항상 오류를 발생(반환)해야 함 - 504 (Gateway Timeout)  ","categories": ["Network"],
        "tags": ["Inflearn","Internet","HTTP","IP","TCP","UDP","PORT","DNS"],
        "url": "/network/inflearn-http/",
        "teaser": null
      },{
        "title": "[IntelliJ IDEA] 단축키 모음",
        "excerpt":"단축키                  Key       Function                       ⌘       Command                 ⇧       Shift                 ⌥       Option                 ⌃       Control                 ↩       Return                 ⌫       Back Space                 ⌦       Delete                 ↑       Up arrow                 ↓       Down arrow                 ←       Left arrow                 →       Right arrow                 ⇞       Page Up                 ⇟       Page Down                 ↖       Home                 ↘       Down                 ⇥       Right Tab                 ⎋       Escape                 §       Section sign                 ⇪       Caps lock                 ⏏       Eject           Remember these Shortcut                  Action        Mac OS       ⊞ Windows                       스마트 코드 완성       ⌃ ⇧ Space       Ctrl + Shift + Space                 어디서나 검색       Double ⇧       Double Shift                 의도적인 동작 및 빠른 수정 사항 표시       ⌘ ↩       Alt + Enter                 코드 생성       ⌘ N, ⌃ ↩       Alt + Ins                 매개변수 정보       ⌘ P       Ctrl + P                 선택의 폭 확장       ⌥ ⌘ ↑       Ctrl + W                 선택의 폭 축소       ⌥ ⌘ ↓       Ctrl + Shift + W                 최근 파일 팝업       ⌘ E       Ctrl + E                 이름 재지정       ⇧ F6       Shift + F6           기본 키맵   일반                  Action        Mac OS       ⊞ Windows                       해당 도구 창 열기       ⌘ 0 … ⌘ 9       Alt + #[0-9]                 모두 저장       ⌘ S       Ctrl + S                 동기화       ⌘ ⌥ Y       Ctrl + Alt + Y                 에디터 최대화 토글       ⌘ ⇧ F12       Ctrl + Shift + F12                 현재 프로필로 현재 파일 검사       ⌥ ⇧ I       Alt + Shift + I                 현재 체계의 빠른 전환       ⌃ §, ⌃ `       Ctrl + BackQuote (`)                 개방형 설정 대화상자       ⌘ ,       Ctrl + Alt + S                 프로젝트 구조 대화상자 열기       ⌘ ;       Ctrl + Alt + Shift + S                 동작 찾기       ⌘ ⇧ A       Ctrl + Shift + A           디버깅                  Action        Mac OS       ⊞ Windows                       넘어가기 / 들어가기       F8 / F7       F8 / F7                 스마트하게 들어가기 / 나가기       ⇧ F7 / ⇧ F8       Shift + F7 / Shift + F8                 커서로 이동       ⌥ F9       Alt + F9                 표현 평가       ⌥ F8       Alt + F8                 프로그램 다시 시작       ⌘ ⌥ R       F9                 중단점 토글       ⌘ F8       Ctrl + F8                 중단점 보기       ⌘ ⇧ F8       Ctrl + Shift + F8           검색 / 교체                  Action        Mac OS       ⊞ Windows                       어디서나 검색       Double ⇧       Double Shift                 찾기       ⌘ F       Ctrl + F                 다음 / 이전 찾기       ⌘ G / ⌘ ⇧ G       F3 / Shift + F3                 교체       ⌘ R       Ctrl + R                 경로로 찾기       ⌘ ⇧ F       Ctrl + Shift + F                 경로로 교체       ⌘ ⇧ R       Ctrl + Shift + R                 다음 발생 선택       ⌃ G       Alt + J                 모든 발생 선택       ⌃ ⌘ G       Ctrl + Alt + Shift + J                 발생 선택 취소       ⌃ G       Alt + Shift + J           편집                  Action        Mac OS       ⊞ Windows                       기본 코드 완성       ^ Space       Ctrl + Space                 스마트 코드 완성       ^ ⇧ Space       Ctrl + Shift + Space                 구문 완성       ⌘ ⇧ ↩       Ctrl + Shift + Enter                 매개변수 정보(메서드 호출 인자 내에서)       ⌘ P       Ctrl + P                 빠른 문서 검색       ^ J       Ctrl + Q                 외부 문서       ⇧ F1       Shift + F1                 간략 정보       ⌘ + mouse       Ctrl + mouse                 캐럿에 오류 설명 표시       ⌘ F1       Ctrl + F1                 코드 생성       ⌘ N, ^ ↩       Alt + Insert                 메서드 오버라이딩       ^ O       Ctrl + O                 메서드 구현       ^ I       Ctrl + I                 둘러싸기       ⌘ ⌥ T       Ctrl + Alt + T                 라인 주석 / 주석 제거       ⌘ /       Ctrl + /                 블록 주석 / 주석 제거       ⌘ ⌥ /       Ctrl + Shift + /                 선택의 폭 확장       ⌥ ↑       Ctrl + W                 선택의 폭 축소       ⌥ ↓       Ctrl + Shift + W                 컨텍스트 정보       ^ ⇧ Q       Alt + Q                 의도적인 동작 및 빠른 수정 사항 표시       ⌥ ↩       Alt + Enter                 코드 리포맷팅       ⌘ ⌥ L       Ctrl + Alt + L                 임포트문 최적화       ^ ⌥ O       Ctrl + Alt + O                 라인 자동 들여쓰기       ^ ⌥ I       Ctrl + Alt + I                 선택된 라인 들여쓰기 / 내어쓰기       ⇥ / ⇧ ⇥       Tab / Shift + Tab                 현재 라인을 클립보드로 자르기       ⌘ X       Ctrl + X, Shift + Delete                 현재 라인을 클립보드로 복사       ⌘ C       Ctrl + C, Ctrl + Insert                 클립보드에서 붙여넣기       ⌘ V       Ctrl + V, Shift + Insert                 최근 버퍼에서 붙여넣기       ⌘ ⇧ V       Ctrl + Shift + V                 현재 라인 복제       ⌘ D       Ctrl + D                 캐럿에서 라인 삭제       ⌘ ⌫       Ctrl + Y                 스마트 라인 병합       ^ ⇧ J       Ctrl + Shift + J                 스마트 라인 분할       ⌘ ↩       Ctrl + Enter                 새 라인 시작       ⇧ ↩       Shift + Enter                 캐럿 또는 선택된 블록에서 단어별 사례 토글       ⌘ ⇧ U       Ctrl + Shift + U                 코드 블록 종료 / 시작 시까지 선택       ⌘ ⇧ ] / ⌘ ⇧ [       Ctrl + Shift + ] / [                 단어 끝으로 삭제       ⌥ ⌦       Ctrl + Delete                 단어 시작으로 삭제       ⌥ ⌫       Ctrl + BackSpace                 코드 블록 확장 / 축소       ⌘ + / ⌘ -       Ctrl + NumPad+ / -                 모두 확장       ⌘ ⇧ +       Ctrl + Shift + NumPad+                 모두 축소       ⌘ ⇧ -       Ctrl + Shift + NumPad-                 활성 에디터 탭 닫기       ⌘ W       Ctrl + F4           리팩터링                  Action        Mac OS       ⊞ Windows                       복사       F5       F5                 이동       F6       F6                 안전 삭제       ⌘ Delete       Alt + Delete                 이름 재지정       ⇧ F6       Shift + F6                 리팩터링하기       ^ T       Ctrl + Alt + Shift + T                 서명 변경       ⌘ F6       Ctrl + F6                 인라인       ⌘ ⌥ N       Ctrl + Alt + N                 메서드 추출       ⌘ ⌥ M       Ctrl + Alt + M                 변수 추출       ⌘ ⌥ V       Ctrl + Alt + V                 필드 추출       ⌘ ⌥ F       Ctrl + Alt + F                 상수 추출       ⌘ ⌥ C       Ctrl + Alt + C                 매개변수 추출       ⌘ ⌥ P       Ctrl + Alt + P           탐색                  Action        Mac OS       ⊞ Windows                       클래스로 이동       ⌘ O       Ctrl + N                 파일로 이동       ⌘ ⇧ O       Ctrl + Shift + N                 기호로 이동       ⌘ ⌥ O       Ctrl + Alt + Shift + N                 다음 / 이전 에디터 탭으로 이동       ^ → / ^ ←       Alt + Right / Left                 이전 도구 창으로 돌아가기       F12       F12                 에디터로(도구 창에서) 이동       ⎋       Esc                 활성 또는 최종 활성 창 숨기기       ⇧ ⎋       Shift + Esc                 라인으로 이동       ⌘ L       Ctrl + G                 최근 파일 팝업       ⌘ E       Ctrl + E                 뒤로 / 앞으로 탐색       ⌘ ⌥ ← / ⌘ ⌥ →       Ctrl + Alt + Left / Right                 최종 편집 위치 탐색       ⌘ ⇧ ⌫       Ctrl + Shift + BackSpace                 어떤 뷰에서든지 현재 파일 또는 기호 선택       ⌥ F1       Alt + F1                 선언으로 이동       ⌘ B / ⌘ Click       Ctrl + B, Ctrl + Click                 구현 사항으로 이동       ⌘ ⌥ B       Ctrl + Alt + B                 빠른 정의 검색 열기       ⌥ Space, ⌘ Y       Ctrl + Shift + I                 타입 선언으로 이동       ^ ⌥ B       Ctrl + Shift + B                 슈퍼 메서드 / 슈퍼 클래스로 이동       ⌘ U       Ctrl + U                 이전 / 다음 방법으로 이동       ^ ↑ / ^ ↓       Alt + Up / Down                 코드 블록 종료 / 시작으로 이동       ⌘ ] / ⌘ [       Ctrl + ] / [                 파일 구조 팝업       ⌘ F12       Ctrl + F12                 타입 계층 구조       ^ H       Ctrl + H                 메서드 계층 구조       ⌘ ⇧ H       Ctrl + Shift + H                 호출 계층 구조       ^ ⌥ H       Ctrl + Alt + H                 다음 / 이전 강조 표시된 오류       F2 / ⇧ F2       F2 / Shift + F2                 소스 편집 / 소스 보기       F4 / ⌘ ↓       F4 / Ctrl + Enter                 탐색 표시줄 표시       ⌥ Home       Alt + Home                 북마크 토글       F3       F11                 연상 기호를 활용한 북마크 토글       ⌥ F3       Ctrl + F11                 숫자 지정 북마크로 이동       ^ 0 … ^ 9       Ctrl + #[0-9]                 북마크 표시       ⌘ F3       Shift + F11           컴파일 및 실행                  Action        Mac OS       ⊞ Windows                       프로젝트 만들기(수정되고 종속된 상태로 컴파일링)       ⌘ F9       Ctrl + F9                 선택된 파일, 패키지 또는 모듈 컴파일       ⌘ ⇧ F9       Ctrl + Shift + F9                 구성 선택 및 실행 / 디버그       ^ ⌥ R / D       Alt + Shift + F10 / F9                 실행 / 디버그       ^ R / D       Shift + F10 / F9                 에디터에서 컨텍스트 구성 실행 / 디버그       ^ ⇧ R / ^ ⇧ D       Ctrl + Shift + F10           사용량 검색                  Action        Mac OS       ⊞ Windows                       사용량 찾기 / 파일의 사용량 찾기       ⌥ F7 / ⌘ F7       Alt + F7 / Ctrl + F7                 파일의 사용량 강조 표시       ⌘ ⇧ F7       Ctrl + Shift + F7                 사용량 표시       ⌘ ⌥ F7       Ctrl + Alt + F7           VCS / 로컬 기록                  Action        Mac OS       ⊞ Windows                       프로젝트를 VCS로 커밋       ⌘ K       Ctrl + K                 프로젝트를 VCS에서 업데이트       ⌘ T       Ctrl + T                 커밋 푸시       ⌘ ⇧ K       Ctrl + Shift + K                 VCS 빠른 팝업       ^ V       Alt + BackQuote (`)           실시간 템플릿                  Action        Mac OS       ⊞ Windows                       실시간 템플릿으로 감싸기       ⌘ ⌥ J       Ctrl + Alt + J                 실시간 템플릿 삽입       ⌘ J       Ctrl + J           KeyMap for Mac      FastCampus KeyMap for Mac     KeyMap for Windows      FastCampus KeyMap for Windows     ","categories": ["tools"],
        "tags": ["IntelliJ","IDEA","HotKey"],
        "url": "/tools/idea-hotkey/",
        "teaser": null
      },{
        "title": "[우아한 유스방 3기] 첫 번째 과제",
        "excerpt":"1. 학습 과정과 현재 자신이 생각하는 역량은? (1000자 이내)  최근에 학습하는 것은 코틀린과 JPA, 스프링(부트)를 학습하고 있습니다. 실무에서 코틀린과 JPA를 사용하게 된 지 얼마 안 되어 코틀린 언어의 특징을 활용한 코딩 스타일을 익히고, ORM의 개념을 숙지하여 JPA를 능숙하고 안전하게 사용할 수 있도록 학습하고 있습니다. 또 팀 내에서도 코드 리뷰를 하며 OOP나 클린 코드, 리팩터링와 관련된 깔끔한 테스트 코드 등을 위해 항상 노력하고 있습니다. 현재 학습하고 있는 것들이 익숙해진다면 도커, K8s 및 클라우드와 MSA 순서로 스터디할 계획입니다.   저의 학습 방식은 주제에 따라 다른 편입니다. 클린 코드나 클린 아키텍처, 이펙티브 자바, 리팩터링 등과 같은 바이블로 알려진 책은 정독 후 까먹은 부분을 다시 보는 편입니다. 이와 다르게 스프링과 같은 프레임워크나 라이브러리, 플랫폼 등과 관련된 내용은 서적을 참고 시 기본 개념만 빠르게 훑고 바로 필요한 부분만 사전처럼 찾아보는 편입니다. 그리고 개발 강의들을 자주 찾아보는 편인데, 이러한 강의들은 강의 내용 외에도 얻어 가는 게 많아 시간적 여유가 된다면 관심이 가는 강의를 사비를 들여서라도 수강하는 편입니다. 최근에는 회사 팀원들과 회사에 필요한 기술 중 하나를 선택해 스터디를 진행하고 있습니다.   제가 생각하는 현재 제 역량은 프로젝트 수행에 필요한 특정 도메인 지식을 지녔다고 가정했을 때, 프로젝트 기본 설정이 가능하고 기본적인 비즈니스 로직(CRUD)구현과 DB 설계 및 클라우드를 활용하여 간단한 인프라 설정 및 CI, CD 설정을 통한 배포 자동화 등이 가능합니다. 즉 기획부터 배포까지의 프로세스를 모두 경험해 보았다는 것이 장점이라고 생각합니다.   하지만 실시간 대용량 트래픽 처리 등은 클라우드에서 지원하는 오토 스케일링 설정 등을 제외하고선 처리 경험이 전무하고 CI, CD의 복잡한 파이프라인 설정 경험 또한 없으며, 도커와 K8s 등은 기본적인 교육만 받아 간단한 개념 정도만 알고 사용할 수 있습니다. 또한 MSA 설계 및 구축 경험이 없어 이와 관련된 트러블 슈팅 경험이 부족하다고 생각됩니다.   2. 선택한 직군이 되려는 이유는 무엇인가요? (1000자 이내)  대학에서 전공으로 배울 때와는 다르게 개발자로 일하면서 기술적으로 새로운 것을 알게 되었을 때 기분이 좋았습니다. 습득한 지식을 머리로만 알고 있다가 프로젝트에 적용하며 퍼즐이 맞춰지는 느낌이 좋았고, 깔끔한 코드를 작성하는 것이 글을 쓰는 것처럼 느껴져 좋았습니다. 그리고 이 모든 것들을 다른 사람들과 다양한 예시를 통해 설명하고, 이야기하는 것이 즐거웠습니다. 그래서 일을 하며 기술적인 측면에서 수많은 선례를 확인하면서 이를 팀원들과 논의하고 토론하며 상황에 맞는 베스트 프랙티스를 찾는 것이 꽤나 즐겁습니다.   개발자 중에서도 백엔드 개발자라는 포지션은 저에겐 꽤나 매력적이었습니다. 윈도우 애플리케이션과 하이브리드 앱 등을 개발한 경험이 있지만 제겐 백엔드 포지션이 적성에 맞는다고 판단했습니다. 핵심 비즈니스 로직을 구현하면서, 클라우드 같은 인프라부터 앱 서버 및 DB, 배포 자동화 같은 많은 영역을 총망라하면서 무언가를 만든다는 게 흥미롭다고 느꼈습니다.   3. 마음이 끌리는 무엇인가에 몰입해 일정 수준의 결과물을 만들어 낸 경험이 있나요? (1000자 이내)  가장 최근에 회사에서 내부 데이터들을 국제 데이터 표준 모델인 HL7의 맞춰 ETL(Extract, Transform, Load) 작업을 한 적이 있습니다. 그 당시 아래와 같은 문제점들이 있었습니다.      코틀린에 대한 부족한 숙련도로 자바만큼 생산성이 높지 않고, 전혀 코틀린스럽지 못한 코딩 스타일   ORM과 JPA의 개념 및 메커니즘 이해도 부족으로 데이터 조회 시 성능 이슈 발생   데이터를 수신하는 외부 서버의 성능 이슈나 일정 같은 외부 요인   해당 업무는 단발성 업무였기 때문에 편한 기술로 데이터를 적절하게 잘라 보내기만 하면 그만이었지만 아이러니하게도 시간이 지날수록 어떻게든 개선해 보려는 마음은 더 커졌던 것 같습니다. 이를 해결하기 위한 저의 노력은 다음과 같습니다.      팀 내 스터디와 코드 리뷰 형태의 강의를 통해 코틀린 언어에 대한 깊은 이해   비동기 요청 및 요청별 새 트랜잭션 처리로 연관관계 및 DB Connection 이슈 해결   외부 요인은 팀 내 공론화를 통해 협력과 집단 지성으로 처리   기술적으로 부족한 부분은 어떻게든 방법을 찾아 개선 및 해결했으나 외부 요인들은 스스로 해결할 수 없었습니다. 따라서 제가 할 수 없는 부분은 대외적으로 알려 공론화시키려고 무던히 애썼습니다. 예측했던 개발 규모와 실제 개발 규모가 달라서 발생한 일정 지연을 사내에 주기적으로 공유하여 일정 조율 측면에서는 다른 분들의 도움을 최대한 받으려 했고, 의사소통 시간을 줄이기 위해 외부 개발자와 직접 교류하면서 외부 업체와도 일정이나 성능 등 협업을 통해 조율하려 노력하였습니다.   비록 큰 성과는 없었고 회사 업무이기에 어찌 보면 노력의 결과가 당연하다 생각될지 모르나 개인적으로는 예전에 비해서 많이 성장했다고 느끼는 경험이었습니다. 어쩔 줄 몰라 손 놓고 있는 상태가 아닌 할 수 있는 선에서 최선을 다하는 제 모습이 스스로 뿌듯했습니다.   4. 우리 회사에 지원하려는 이유는 무엇인가요? (500자 이내)  현재의 저라는 개발자를 만들어준 우아한테크캠프 Pro 교육을 통해 관심이 생겨 지원하였습니다. 개인적으로 이 교육을 굉장히 힘들 시기에 수강하게 되었습니다. 임금체불로 회사를 그만두게 되면서 실패, 좌절을 경험하면서 이직에 어려움을 겪고 개발자를 그만둘지에 대한 깊은 고민을 하던 찰나였습니다. 이때 심리적으로 이 교육이 많이 힘이 되었습니다. 해당 교육을 통해 앞으로의 성장 방향을 알게 되면서 시간만 더 주어지면 일어설 수 있다는 자신감이 생겼습니다.   결론적으로 저는 힘든 시절 지탱해 준 교육에 감사하며 이렇게 업계에 발전을 위해 힘쓰는 곳은 얼마나 될까라고 생각했습니다. 처우와 복지가 좋은 회사도 많고 화려한 기술 스택을 사용하는 곳도 많지만 일을 하려면 이런 곳에서 선한 영향력을 주고받으며 해야되지 않을까라는 생각으로 지원하였습니다.  ","categories": ["Study"],
        "tags": ["우아한 유스방","스터디"],
        "url": "/study/woowa-youth-assignment-01/",
        "teaser": null
      },{
        "title": "[우아한 유스방 3기] 두 번째 과제",
        "excerpt":"우아한형제들은 어떤 비전을 가지는지  개인적으로 알아본 우아한형제들의 비전은 아래와 같습니다.      정보 기술을 활용한 배달 산업에 발전 (1.0)   좋은 음식을 먹고 싶은 곳에서 (2.0)   문 앞으로 배달되는 일상의 행복 (3.0)   비전은 다시 말해 목표라고 할 수 있는데 비전별로 제 생각을 조금씩 보태보자면 이렇습니다. 먼저 1.0 비전은 기존 대한민국 내에 원활하지 못했던 배달 문화에 대해서 체계를 잡는 것이라 생각합니다. 기존에는 업체별로 통합되지 않은 배달 서비스로 인해 소비자 입장에서 이용하기 불편하다는 단점을 개선 및 극복하는 것이 목표였다고 추측합니다. 궁극적으로 배달 산업의 발전과 활성화가 핵심이라고 보입니다.   두 번째 2.0은 좋은 음식에 대한 정의가 사람마다 다른데 제가 볼 때 좋은 음식이란 소비자가 원하는 음식 입니다. 따라서 가장 빨리 배송이 되는 음식, 고향에서만 판매하는 특산품 등 정의가 모두 다르지만 이 좋은 음식을 소비자가 원하는 곳까지 제공하겠다가 목표이며, 여기서 핵심은 이를 어떻게든 가능하게 하겠다가 중요한 포인트라고 생각합니다.   마지막 비전을 해석해 보자면 퀵커머스를 통한 사람들의 삶의 질 향상입니다. 배송 속도의 개선, 배송되는 음식의 신선도 등은 당연히 보장되어 소비자들의 만족도를 올리는 것이 목표일 것입니다. 다만 개인적으로 이와 동시에 삶의 질 향상은 소비자 뿐 아니라 배송 라이더들의 업무 환경까지 포함되어야 한다고 생각합니다. 따라서 이를 극복하려는 기술과 인프라의 발전이 핵심 가치가 될 것입니다.   우아한형제들은 어떻게 일을 하는지  우아한형제들은 4개의 핵심 가치와 우아한 인재상을 가지고 있고, 송파구에서 일을 더 잘하는 11가지 방법이라는 유명한 룰이 있는 것으로 알고 있습니다.   먼저 규율 위의 자율, 진지함과 위트, 스타보다 팀웍, 열심만큼 성과 같은 4개의 핵심 가치가 업무 문화로써 자리 잡고 있는데, 4개 모두 전체적으로 긍정적으로 밝게 일하되 해야 하는 것은 확실하게라는 내용을 포함하고 있다고 보입니다. 어찌 보면 놀이터가 아닌 회사로써 당연한 얘기지만 이렇게 핵심 가치로 두어 모두에게 한 번 더 상기시켜 자유로운 분위기와 업무에 대한 책임감 모두를 강조하고 있다고 생각합니다.   우아한 인재상은 근면 성실, 새 시대 새 일꾼, 근검절약, 배려와 협동 4가지인데 어찌 보면 모두 당연한 이야기라고 판단됩니다. 개인적으로는 배려와 협동 내용은 위 핵심 가치의 스타보다 팀웍과 관련된 내용이라 연관 있는 업무 문화라 관심이 갑니다.   송파구에서 일을 더 잘하는 11가지 방법은 아래와 같습니다.     12시 1분은 12시가 아니다.   실행은 수직적! 문화는 수평적~   잡담을 많이 나누는 것이 경쟁력이다.   쓰레기는 먼저 본 사람이 줍는다.   휴가나 퇴근시 눈치주는 농담을 하지 않는다.   보고는 팩트에 기반한다.   일의 목적, 기간, 결과, 공유자를 고민하며 일한다.   책임은 실행한 사람이 아닌 결정한 사람이 진다.   가족에게 부끄러운 일은 하지 않는다.   모든 일의 궁극적인 목적은 ‘고객창출’과 ‘고객만족’이다.   이끌거나, 따르거나, 떠나거나!   모두 맞는 이야기이고 저도 모두 동의하는 내용이지만 개인적으로 잡담을 많이 나누는 것이 경쟁력이다. 항목을 좋아합니다. 대화만큼 사람과 사람 간에 관계에 영향을 크게 미치는 게 없을 것이라 생각하고 저는 이것이 업무 생산성 측면에서 매우 중요한 점이라고 여깁니다.   그 이유는 첫 번째로 회사는 같이 일하는 동료와의 관계 개선입니다. 우리는 하루에 제일 많은 시간을 회사에서 업무를 하면서 보내는 데 항상 마주하는 사람들이 옆자리 동료들입니다. 이들과 좋은 관계를 유지하여 사람한테 받는 스트레스만 없애도 출근길이 싫지는 않을 것이라고 보는 편입니다.   두 번째로 잡담이라고 해서 모든 대화가 영양가 없지만은 않다고 생각합니다. 클린 애자일이라는 책을 보면 기술의 발달로 재택근무가 가능해졌지만 이로 인해 기존에 오프라인에서 업무 시 대화를 통해 배우는 것이 부족하다고 지적하는 내용이 나옵니다. 물론 이는 마틴 파울러의 주관적인 견해일 뿐이지만, 개인적으로도 이 의견에 동의하는 편입니다. 잡담과 대화를 통해 배우는 간접 경험도 개인의 성장에 크게 기여하는 요소 중 하나라는 것은 분명한 사실입니다.   우아한형제들은 어떤 서비스를 하고 있는지  배달/포장     배민1            라이더가 한 번에 한 집만 빠르게 배달하는 서비스           배민포장            음식 포장을 앱으로 주문 결제하는 서비스           배민로봇            배민로봇(딜리)이 음식을 전달하는 서비스           커머스     배민B마트            상품 주문 시 바로 배달하는 장보기 서비스           배민스토어            꽃이나 식료품 등 다양한 카테고리의 상품을 배달하는 서비스           배민쇼핑라이브            음식을 라이브로 시청 후 구매할 수 있는 서비스           배민선물하기            배민에서 사용 가능한 밥 상품권 선물 서비스           배민전국별미            지역 별 대표 별미 및 특산품 등을 택배로 배송하는 서비스           사장님/라이더     배민사장님광장            장사에 필요한 서비스 및 콘텐츠를 사장님에게 연결해주는 서비스           배민상회            외식업 사장님을 위한 온라인 식자재 전문몰 서비스           배민키친            창업이나 영업 확장을 위해 독립된 주방 공간을 대여하는 서비스           배민커넥트            내가 원하는 시간에 배달 업무를 할 수 있게 제공하는 서비스           컬처     배민문방구            배민다움을 손끝으로 전하는 메신저 서비스           만화경            온라인 만화 서비스           각 서비스의 조직도를 예측해 보기  개인적으로 하나의 서비스가 탄력적으로 운영되려면 포지션별로 한 팀이 되어 할당되는 업무를 처리하는 형태가 아니라 해당 서비스의 필요한 인재들이 모여 한 팀을 이뤄 주도적으로 업무를 처리해야 한다고 생각합니다. 애자일 방법론을 얘기하는 많은 곳에서 이런 팀을 whole team이라고 하는데 이리저리 살펴본 결과 우아한형제들 또한 대부분 팀이 다양한 포지션으로 구성되어 있었습니다. (다만 이 팀은 모두가 포지션 별 전문가라는 전제조건이 있어야 합니다.) 따라서 기업 문화가 좋다라고 알려진 우아한형제들도 서비스를 서브도메인 단위로 나눠 서비스를 더 작게 나누고 이를 수행하는 한 팀이 구성되어 있을 것이라고 예상했지만 알아본 결과 예상과는 조금 다른 부분도 있었습니다.   알아본 우아한형제들 실제 서비스 별 조직 형태   배민사장님서비스실  배달의민족 비즈니스에서 사장님이 필요한 정보를 관리하고, 필요한 서비스와 시스템을 운영     배민셀프서비스팀            사장님들이 더 쉽고, 빠르고, 효과적으로 장사할 수 있도록 도와주는 팀           배민세일즈서비스팀            사장님들이 더 쉽고 빠르게 배달의민족에 입점하는 것을 도와주는 팀           주문접수채널서비스팀            사장님들께 주문 전달을 도와주는 팀           배민플랫폼실  배달의민족 서비스를 운영하는데 필요한 기본 데이터 생성, 관리, 운영     가게시스템팀            가게에 대한 정보의 근간이 되는 데이터를 다루는 팀           메뉴시스템팀            메뉴와 관련된 기초 데이터를 다루는 팀           배민상품시스템팀            다양한 광고 상품을 기획, 개발, 개선하는 팀           중계시스템팀            사용자의 주문 이후 프로세스를 담당하는 팀           프렌차이즈시스템팀            관련 페이지가 없지만 가맹점과 관련된 서비스를 담당하는 팀이라고 추측           B2B사업실  배달의민족 B2B 생태계를 위한 효과적인 프로세스와 콘텐츠 및 서비스, 그리고 광고상품 제공     B2B사업기획팀            데이터 분석을 통한 신규 사업 추진 및 광고 상품 전략을 통한 새로운 광고 비즈니스 구축           채널영업기획팀            세일즈 채널 전략을 세우고 관리하는 팀           상품운영팀            광고 프로세스 개선과 고도화를 추진하는 팀           온라인영업팀            비대면 영업 전략 수립 및 성과를 관리하는 팀           배민사장님광장팀            외식업 포털 배민사장님광장 서비스 및 콘텐츠 기획하고 운영하는 팀           결제정산플랫폼실  결제 트래픽 처리 및 선불충전을 제공하는 배민페이머니와 배민페이 고도화, 정산 및 지급     코어결제팀            결제서비스를 기획, 운영하는 팀           배민페이프로덕트팀            배민페이, 배민페이머니 등 결제수단 제공 및 결제플랫폼 프로덕트를 서비스하는 팀           혜택플랫폼팀            고객 및 사장님들께 혜택을 제공하는 도구 및 플랫폼을 구축하는 팀           정산플랫폼팀            제공되는 서비스의 B2B 정산을 담당하는 팀           Next결제팀            외부 비공개 (추측 불가능)           배민공통프로덕트실     리뷰플랫폼팀            리뷰서비스를 위한 배달의민족의 공통 리뷰플랫폼을 담당하는 팀           회원플랫폼팀            배민 회원 및 외식업 사장님, 커머스 셀러 회원 등을 통합 관리하는 회원플랫폼을 담당하는 팀           검색플랫폼팀            가게 및 음식 검색을 위한 배달의민족 검색 서비스와 공통 검색플랫폼을 담당하는 팀           딜리버리프로덕트실     배민1, B마트 주문을 즉시 배달하기 위한 배달인프라 시스템을 기획, 개발을 담당하는 팀   배민서비스실     배민서비스개발팀            배달의민족 홈, 리스팅, 상세 등 고객 서비스 전반의 백엔드 도메인을 개발, 개선 업무를 담당하는 팀           B마트서비스팀            어떤 상품이든 1시간 이내로 배달받을 수 있는 라스트 마일을 담당하는 quick-commerce를 담당하는 팀           물류플랫폼실     물류에 관련된 SCM, OMS, WMS, TMS 등의 시스템을 개발하는 플랫폼을 담당하는 팀   배민상회서비스실     사장님에게 필요한 모든 식자재를 합리적으로 제공하는 서비스 배민상회를 담당하는 팀   배민상회 e-Commerce 회원관리, 상품관리, 주문/결제, CRM, CMS 시스템 백엔드 개발   그 외   만화경     웹툰 만화경을 담당하는 팀   전국별미     지역 제철 별미를 주문하기 위한 이커머스 플랫폼을 담당하는 팀   우아한테크코스     좋은 프로그래머로 성장하는데 필요한 교육 제공, 역량을 갖춘 개발자를 배출하는 개발자 양성 조직을 담당하는 팀  ","categories": ["Study"],
        "tags": ["우아한 유스방","스터디"],
        "url": "/study/woowa-youth-assignment-02/",
        "teaser": null
      }]
